<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>3. Configuring Request Mappings to Secure URLs</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="3. Configuring Request Mappings to Secure URLs">3. Configuring Request Mappings to Secure URLs</a></h1>You can choose among several approaches to configuring request mappings for secure application URLs. The goal is to map URL patterns to the roles required to access those URLs. The approaches are:
<ul class="star">
<li><code>&#64;Secured</code> annotations (default approach)</li>
<li>A simple Map in <code>Config.groovy</code></li>
<li><code>Requestmap</code> domain class instances stored in the database</li>
</ul><p class="paragraph"/>You can only use one method at a time. You configure it with the <code>securityConfigType</code> attribute; the value has to be an <code>SecurityConfigType</code> enum value.<p class="paragraph"/>To use annotations, specify <code>SecurityConfigType.Annotation</code>, or leave it unspecified since it's the default:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.SecurityConfigType<p class="paragraph"/>...<p class="paragraph"/>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.Annotation</pre></div><p class="paragraph"/>See <a href="../guide/single.html#3.1 Defining Secured Annotations" class="guide">Defining Secured Annotations</a>.<p class="paragraph"/>To use the <code>Config.groovy</code> Map, specify <code>SecurityConfigType.InterceptUrlMap</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.SecurityConfigType<p class="paragraph"/>...<p class="paragraph"/>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.InterceptUrlMap</pre></div><p class="paragraph"/>See <a href="../guide/single.html#3.2 Simple Map in Config.groovy" class="guide">Simple Map in Config.groovy</a>.<p class="paragraph"/>To use <code>Requestmap</code> entries, specify <code>SecurityConfigType.Requestmap</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.SecurityConfigType<p class="paragraph"/>...<p class="paragraph"/>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.Requestmap</pre></div><p class="paragraph"/>See <a href="../guide/single.html#3.3 Requestmap Instances Stored in the Database" class="guide">Requestmap Instances Stored in the Database</a>.<p class="paragraph"/>Most applications are mostly public, with some pages only accessible to authenticated users with various roles. In this case, it makes more sense to leave URLs open by default and restrict access on a case-by-case basis. However, if your application is primarily secure, you can use a pessimistic lockdown approach to deny access to all URLs that do not have an applicable URL-Role configuration.<p class="paragraph"/>To use the pessimistic approach, add this line to <code>grails-app/conf/Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>grails.plugins.springsecurity.rejectIfNoRule = <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>Any requested URL that does not have a corresponding rule will be denied to all users.<p class="paragraph"/><h4>URLs and Authorities</h4><p class="paragraph"/>In each approach you configure a mapping for a URL pattern to the role(s) that are required to access those URLs, for example, <code>/admin/user/&#42;&#42;</code> requires <code>ROLE_ADMIN</code>. In addition, you can combine the role(s) with tokens such as IS_AUTHENTICATED_ANONYMOUSLY, IS_AUTHENTICATED_REMEMBERED, and IS_AUTHENTICATED_FULLY. One or more <code>Voter</code>s will process any tokens and enforce a rule based on them:
<ul class="star">
<li><code>IS_AUTHENTICATED_ANONYMOUSLY</code></li>
<ul class="star">
<li>signifies that anyone can access this URL. By default the <code>AnonymousAuthenticationFilter</code> ensures an 'anonymous' <code>Authentication</code> with no roles so that every user has an authentication. The token accepts any authentication, even anonymous.</li>
</ul>
<li><code>IS_AUTHENTICATED_REMEMBERED</code></li>
<ul class="star">
<li>requires the user to be authenticated through a remember-me cookie or an explicit login.</li>
</ul>
<li><code>IS_AUTHENTICATED_FULLY</code></li>
<ul class="star">
<li>requires the user to be fully authenticated with an explicit login.</li>
</ul></ul><p class="paragraph"/>With <code>IS_AUTHENTICATED_FULLY</code> you can implement a security scheme whereby users can check a remember-me checkbox during login and be auto-authenticated each time they return to your site, but must still log in with a password for some parts of the site. For example, allow regular browsing and adding items to a shopping cart with only a cookie, but require an explicit login to check out or view purchase history.<p class="paragraph"/>For more information on <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code>, see the Javadoc for <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/vote/AuthenticatedVoter.html" target="blank">AuthenticatedVoter</a><p class="paragraph"/><h4>Comparing the Approaches</h4><p class="paragraph"/>Each approach has its advantages and disadvantages. Annotations and the <code>Config.groovy</code> Map are less flexible because they are configured once in the code and you can update them only by restarting the application (in prod mode anyway). In practice this limitation is minor, because security mappings for most applications are unlikely to change at runtime.<p class="paragraph"/>On the other hand, storing <code>Requestmap</code> entries enables runtime-configurability. This approach gives you a core set of rules populated at application startup that you can edit, add to, and delete as needed. However, it separates the security rules from the application code, which is less convenient than having the rules defined in <code>grails-app/conf/Config.groovy</code> or in the applicable controllers using annotations.<p class="paragraph"/>URLs must be mapped in lowercase if you use the <code>Requestmap</code> or <code>grails-app/conf/Config.groovy</code> map approaches. For example, if you have a FooBarController, its urls will be of the form /fooBar/list, /fooBar/create, and so on, but these must be mapped as /foobar/, /foobar/list, /foobar/create. This mapping is handled automatically for you if you use annotations.<p class="paragraph"/><h2><a name="3.1 Defining Secured Annotations">3.1 Defining Secured Annotations</a></h2>The plugin supplies an <code>&#64;Secured</code> annotation that you can use in your controllers to configure which roles are required for which actions.<p class="paragraph"/>You can define the annotation at the class level, meaning that the specified roles are required for all actions, or at the action level, or both. If the class and an action are annotated then the action annotation values will be used since they're more specific.<p class="paragraph"/>For example, given this controller:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.mycompany.myapp<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.Secured<p class="paragraph"/>class SecureAnnotatedController &#123;<p class="paragraph"/>   @Secured(&#91;'ROLE_ADMIN'&#93;)
   def index = &#123;
      render 'you have ROLE_ADMIN'
   &#125;<p class="paragraph"/>   @Secured(&#91;'ROLE_ADMIN', 'ROLE_SUPERUSER'&#93;)
   def adminEither = &#123;
      render 'you have ROLE_ADMIN or SUPERUSER'
   &#125;<p class="paragraph"/>   def anybody = &#123;
      render 'anyone can see <span class="java&#45;keyword">this</span>'
   &#125;
&#125;</pre></div><p class="paragraph"/>you need to be authenticated and have <code>ROLE_ADMIN</code> to see <code>/myapp/secureAnnotated</code> (or <code>/myapp/secureAnnotated/index</code>) and be authenticated and have <code>ROLE_ADMIN</code> or <code>ROLE_SUPERUSER</code> to see <code>/myapp/secureAnnotated/adminEither</code>. Any user can access <code>/myapp/secureAnnotated/anybody</code>.<p class="paragraph"/>Often most actions in a controller require similar access rules, so you can also define annotations at the class level:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.mycompany.myapp<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.Secured<p class="paragraph"/>@Secured(&#91;'ROLE_ADMIN'&#93;)
class SecureClassAnnotatedController &#123;<p class="paragraph"/>   def index = &#123;
      render 'index: you have ROLE_ADMIN'
   &#125;<p class="paragraph"/>   def otherAction = &#123;
      render 'otherAction: you have ROLE_ADMIN'
   &#125;<p class="paragraph"/>   @Secured(&#91;'ROLE_SUPERUSER'&#93;)
   def <span class="java&#45;keyword">super</span> = &#123;
      render '<span class="java&#45;keyword">super</span>: you have ROLE_SUPERUSER'
   &#125;
&#125;</pre></div><p class="paragraph"/>Here you need to be authenticated and have <code>ROLE_ADMIN</code> to see <code>/myapp/secureClassAnnotated</code> (or <code>/myapp/secureClassAnnotated/index</code>) or <code>/myapp/secureClassAnnotated/otherAction</code>. However, you must have <code>ROLE_SUPERUSER</code> to access <code>/myapp/secureClassAnnotated/super</code>. The action-scope annotation overrides the class-scope annotation.<p class="paragraph"/><h4>controllerAnnotations.staticRules</h4><p class="paragraph"/>You can also define 'static' mappings that cannot be expressed in the controllers, such as '/<strong class="bold"></strong>' or for JavaScript, CSS, or image URLs. Use the <code>controllerAnnotations.staticRules</code> property, for example:<p class="paragraph"/><div class="code"><pre>grails.plugins.springsecurity.controllerAnnotations.staticRules = &#91;
   '/js/admin/&#42;&#42;': &#91;'ROLE_ADMIN'&#93;,
   '/somePlugin/&#42;&#42;': &#91;'ROLE_ADMIN'&#93;
&#93;</pre></div><p class="paragraph"/>This example maps all URLs associated with 'somePlugin' to <code>ROLE_ADMIN</code>; annotations are not an option here because you would not edit plugin code for a change like this.
<h2><a name="3.2 Simple Map in Config.groovy">3.2 Simple Map in Config.groovy</a></h2>To use this approach, just define a Map in <code>Config.groovy</code>:<p class="paragraph"/><div class="code"><pre>grails.plugins.springsecurity.interceptUrlMap = &#91;
   '/secure/&#42;&#42;':    &#91;'ROLE_ADMIN'&#93;,
   '/finance/&#42;&#42;':   &#91;'ROLE_FINANCE', 'IS_AUTHENTICATED_FULLY'&#93;,
   '/js/&#42;&#42;':        &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;,
   '/css/&#42;&#42;':       &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;,
   '/images/&#42;&#42;':    &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;,
   '/&#42;':            &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;,
   '/login/&#42;&#42;':     &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;,
   '/logout/&#42;&#42;':    &#91;'IS_AUTHENTICATED_ANONYMOUSLY'&#93;
&#93;</pre></div><p class="paragraph"/>When using this approach, make sure that you order the rules correctly. The first applicable rule is used, so for example if you have a controller that has one set of rules but an action that has stricter access rules, e.g.<p class="paragraph"/><div class="code"><pre>'/secure/&#42;&#42;':              &#91;'ROLE_ADMIN', 'ROLE_SUPERUSER'&#93;,
'/secure/reallysecure/&#42;&#42;': &#91;'ROLE_SUPERUSER'&#93;</pre></div><p class="paragraph"/>then this would fail - it wouldn't restrict access to <code>/secure/reallysecure/list</code> to a user with <code>ROLE_SUPERUSER</code> since the first URL pattern matches, so the second would be ignored. The correct mapping would be<p class="paragraph"/><div class="code"><pre>'/secure/reallysecure/&#42;&#42;': &#91;'ROLE_SUPERUSER'&#93;
'/secure/&#42;&#42;':              &#91;'ROLE_ADMIN', 'ROLE_SUPERUSER'&#93;,</pre></div><p class="paragraph"/><h2><a name="3.3 Requestmap Instances Stored in the Database">3.3 Requestmap Instances Stored in the Database</a></h2>With this approach you store mapping entries in the database, using the <code>Requestmap</code> domain class. <code>Requestmap</code> has a <code>url</code> property which contains the secured URL pattern and a <code>configAttribute</code> property containing a comma-delimited list of required roles and/or tokens such as <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code>.<p class="paragraph"/>Creation of <code>Requestmap</code> entries is the same as for any Grails domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Requestmap(url: '/js/&#42;&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/css/&#42;&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/images/&#42;&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/login/&#42;&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/logout/&#42;&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/&#42;', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/profile/&#42;&#42;', configAttribute: 'ROLE_USER').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/admin/&#42;&#42;', configAttribute: 'ROLE_ADMIN').save()
<span class="java&#45;keyword">new</span> Requestmap(url: '/admin/user/&#42;&#42;', configAttribute: 'ROLE_SUPERVISOR').save()</pre></div><p class="paragraph"/>Unlike the <code>Config.groovy</code> Map approach above, you don't need to worry about <code>Requestmap</code> entry order since the plugin calculates the most specific rule that applies to the current request.<p class="paragraph"/><h4>Requestmap cache</h4><p class="paragraph"/><code>Requestmap</code> entries are cached for performance, but this has an impact on runtime configurability. If you create, edit, or delete an instance, the cache must be flushed and repopulated to be consistent with the database. You can call <code>springSecurityService.clearCachedRequestmaps()</code> to do this. For example, if you create a <code>RequestmapController</code> the <code>save</code> action should look like this (and the update and delete actions should similarly call <code>clearCachedRequestmaps()</code>):<p class="paragraph"/><div class="code"><pre>class RequestmapController &#123;<p class="paragraph"/>   def springSecurityService<p class="paragraph"/>   ...<p class="paragraph"/>   def save = &#123;
      def requestmapInstance = <span class="java&#45;keyword">new</span> Requestmap(params)
      <span class="java&#45;keyword">if</span> (!requestmapInstance.save(flush: <span class="java&#45;keyword">true</span>)) &#123;
         render view: 'create', model: &#91;requestmapInstance: requestmapInstance&#93;
         <span class="java&#45;keyword">return</span>
      &#125;<p class="paragraph"/>      springSecurityService.clearCachedRequestmaps()
      flash.message = <span class="java&#45;quote">"$&#123;message(code: '<span class="java&#45;keyword">default</span>.created.message', args: &#91;message(code: 'requestmap.label', <span class="java&#45;keyword">default</span>: 'Requestmap'), requestmapInstance.id&#93;)&#125;"</span>
      redirect action: show, id: requestmapInstance.id
   &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="3.4 Using Expressions to Create Descriptive, Fine-Grained Rules">3.4 Using Expressions to Create Descriptive, Fine-Grained Rules</a></h2>Spring Security uses the <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html" target="blank">Spring Expression Language (SpEL)</a>, which allows you to declare the rules for guarding URLs more descriptively than does the traditional approach, and also allows much more fine-grained rules. Where you traditionally would specify a list of role names and/or special tokens (for example, <code>IS_AUTHENTICATED_FULLY</code>), with <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/el-access.html" target="blank">Spring Security&#39;s expression support</a>, you can instead use the embedded scripting language to define simple or complex access rules.<p class="paragraph"/>You can use expressions with any of the previously described approaches to securing application URLs. For example, consider this annotated controller:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.yourcompany.yourapp<p class="paragraph"/><span class="java&#45;keyword">import</span> grails.plugins.springsecurity.Secured<p class="paragraph"/>class SecureController &#123;<p class="paragraph"/>   @Secured(&#91;<span class="java&#45;quote">"hasRole('ROLE_ADMIN')"</span>&#93;)
   def someAction = &#123;
      &#8230;
   &#125;<p class="paragraph"/>   @Secured(&#91;<span class="java&#45;quote">"authentication.name == 'ralph'"</span>&#93;)
   def someOtherAction = &#123;
      &#8230;
   &#125;
&#125;</pre></div><p class="paragraph"/>In this example, <code>someAction</code> requires <code>ROLE_ADMIN</code>, and <code>someOtherAction</code> requires that the user be logged in with username 'ralph'.<p class="paragraph"/>The corresponding <code>Requestmap</code>s would be<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Requestmap(url: <span class="java&#45;quote">"/secure/someAction"</span>,
               configAttribute: <span class="java&#45;quote">"hasRole('ROLE_ADMIN'"</span>).save()<p class="paragraph"/><span class="java&#45;keyword">new</span> Requestmap(url: <span class="java&#45;quote">"/secure/someOtherAction"</span>,
               configAttribute: <span class="java&#45;quote">"authentication.name == 'ralph'"</span>).save()</pre></div><p class="paragraph"/>and the corresponding static mappings would be<p class="paragraph"/><div class="code"><pre>grails.plugins.springsecurity.interceptUrlMap = &#91;
   '/secure/someAction':      &#91;<span class="java&#45;quote">"hasRole('ROLE_ADMIN'"</span>&#93;,
   '/secure/someOtherAction': &#91;<span class="java&#45;quote">"authentication.name == 'ralph'"</span>&#93;
&#93;</pre></div><p class="paragraph"/>The Spring Security docs have a <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/el-access.html#el-common-built-in" target="blank">table listing the standard expressions</a>, which is copied here for reference:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Expression</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td><code>hasRole(role)</code></td><td>Returns true if the current principal has the specified role.</td></tr><tr class="table-even"><td><code>hasAnyRole(role1,role2)</code></td><td>Returns true if the current principal has any of the supplied roles (given as a comma-separated list of strings)</td></tr><tr class="table-odd"><td><code>principal</code></td><td>Allows direct access to the principal object representing the current user</td></tr><tr class="table-even"><td><code>authentication</code></td><td>Allows direct access to the current Authentication object obtained from the SecurityContext</td></tr><tr class="table-odd"><td><code>permitAll</code></td><td>Always evaluates to true</td></tr><tr class="table-even"><td><code>denyAll</code></td><td>Always evaluates to false</td></tr><tr class="table-odd"><td><code>isAnonymous()</code></td><td>Returns true if the current principal is an anonymous user</td></tr><tr class="table-even"><td><code>isRememberMe()</code></td><td>Returns true if the current principal is a remember-me user</td></tr><tr class="table-odd"><td><code>isAuthenticated()</code></td><td>Returns true if the user is not anonymous</td></tr><tr class="table-even"><td><code>isFullyAuthenticated()</code></td><td>Returns true if the user is not an anonymous or a remember-me user</td></tr></table><p class="paragraph"/>In addition, you can use a web-specific expression <code>hasIpAddress</code>. However, you may find it more convenient to separate IP restrictions from role restrictions by using the <a href="../guide/single.html#10.8. IP Address Restrictions" class="guide">IP address filter</a>.<p class="paragraph"/>To help migrate traditional configurations to expressions, here's a table comparing various configurations and their corresponding expressions:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Traditional</strong></th><th><strong class="bold">Expression</strong></th></tr><tr class="table-odd"><td><code>ROLE_ADMIN</code></td><td><code>hasRole('ROLE_USER')</code></td></tr><tr class="table-even"><td><code>ROLE_USER,ROLE_ADMIN</code></td><td><code>hasAnyRole('ROLE_USER,ROLE_ADMIN')</code></td></tr><tr class="table-odd"><td><code>ROLE_ADMIN,IS_AUTHENTICATED_FULLY</code></td><td><code>hasRole('ROLE_ADMIN') and isFullyAuthenticated()</code></td></tr><tr class="table-even"><td><code>IS_AUTHENTICATED_ANONYMOUSLY</code></td><td><code>permitAll</code></td></tr><tr class="table-odd"><td><code>IS_AUTHENTICATED_REMEMBERED</code></td><td><code>isAnonymous() or isRememberMe()</code></td></tr><tr class="table-even"><td><code>IS_AUTHENTICATED_FULLY</code></td><td><code>isFullyAuthenticated()</code></td></tr></table><p class="paragraph"/>
    
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{
var pageTracker = _gat._getTracker('UA-16219500-1');
pageTracker._trackPageview();
} catch(err) {}
</script>
</body>
</html>
