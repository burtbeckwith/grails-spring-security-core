<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>2 Differences Between the Spring Security and Acegi Plugins</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    The Spring Security plugin is a successor to the <a href="http://grails.org/plugin/acegi/" target="blank">Acegi plugin</a>. The sections that follow compare the two.<p class="paragraph"/><h4>Core Similarities and Differences</h4><p class="paragraph"/>The Spring Security plugin retains many core features of the Acegi plugin:
<ul class="star">
<li>Form-based authentication</li>
<li>Storing users, roles, and optionally requestmaps in the database, with access through domain classes</li>
<li>Guarding URLs with annotations, requestmap domain class, or static configuration</li>
<li>Security tags</li>
<li>Security service</li>
<li>Security events</li>
<li>Ajax login</li>
<li>Basic authentication</li>
<li>Switch User</li>
<li>Channel security</li>
<li>IP address restrictions</li>
</ul><p class="paragraph"/>and adds several new features:
<ul class="star">
<li>Digest authentication</li>
<li>Session Fixation Prevention</li>
<li>Salted passwords</li>
<li>Certificate (x509) login</li>
<li>Hierarchical roles</li>
<li>Account locking and forcing password change</li>
</ul><p class="paragraph"/><h4>Features Not Included in the Spring Security Plugin</h4><p class="paragraph"/>The following features are not included in the Spring Security plugin, but are (or will be) available in secondary plugins that extend and depend on the core plugin:
<ul class="star">
<li><a href="http://grails.org/plugin/spring-security-openid" target="blank">OpenID</a></li>
<li><a href="http://grails.org/plugin/spring-security-acl" target="blank">ACL</a></li>
<li><a href="http://grails.org/plugin/spring-security-ldap" target="blank">LDAP</a></li>
<li><a href="http://grails.org/plugin/spring-security-cas" target="blank">CAS</a></li>
<li>User registration</li>
<li>Facebook</li>
<li>NTLM</li>
<li>Kerberos</li>
</ul><p class="paragraph"/><h4>Script Differences</h4><p class="paragraph"/>To initialize the Acegi plugin, you run <code>create-auth-domains</code>. This initialization creates <code>grails-app/conf/SecurityConfig.groovy</code> to allow configuration customization; creates the User, Role, and Requestmap domain classes; and creates the Login and Logout controllers and views. Another Acegi script, <code>generate-manager</code>, creates CRUD pages for the domain classes. (The earlier version of Grails did not scaffold many-to-many relationships well, so these GSPs were necessary.)In addition, a <code>generate-registration</code> script installs a basic user registration controller.<p class="paragraph"/>The Spring Security plugin uses only one script, <a href="../ref/Scripts/s2-quickstart.html" class="Scripts">s2-quickstart</a>. It is similar to <code>create-auth-domains</code> because it creates domain classes and login and logout bcontrollers, but it appends files to <code>grails-app/conf/Config.groovy</code> instead of creating a standalone configuration file. There is no equivalent to <code>generate-manager</code> or <code>generate-registration</code> because an optional UI plugin  generates domain class management screens, an admin console, and forgot password and registration workflows. If you want to create your own CRUD pages, you can use the standard Grails <code>generate-all</code> script. Various sections of this documentation discuss required changes to the generated source files, for example, encrypting passwords before saving or updating a user.<p class="paragraph"/><h4>UserDetails Differences</h4><p class="paragraph"/>The Acegi plugin extends the <code>UserDetails</code> instance and adds an accessor for the person domain class instance that is used to populate the <code>UserDetails</code>. Because the <code>Authentication</code> is kept in the HTTP session and the <code>UserDetails</code> is attached to that, it is easy to access non-security data such as full name, email, and so on without hitting the database.<p class="paragraph"/>However, with this approach, if the domain class has a lot of data, you increase the size of the session payload, which is exacerbated by clustered sessions. Further, any lazy-loaded collections fail to load after retrieving the person from the session because it would have become a detached Hibernate object. This problem is addressed by a call to <code>person.attach()</code> or by reloading by id, for example:<p class="paragraph"/><div class="code"><pre>def userDetails = authenticateService.principal()
def person = userDetails.domainClass
person = Person.get(person.id)</pre></div><p class="paragraph"/>But with this approach, the person class is essentially a very large wrapper around its primary key since that's the real data you're storing.<p class="paragraph"/>To resolve this issue, the Spring Security plugin does not store the domain class but instead stores the id so you can retrieve the person easily:<p class="paragraph"/><div class="code"><pre>def userDetails = springSecurityService.principal
person = Person.get(userDetails.id)</pre></div><p class="paragraph"/>The preceding approach works because the <code>UserDetails</code> implementation is an instance of <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code>, which extends the standard Spring Security <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html" target="blank">User</a> and adds a <code>getId()</code> method.<p class="paragraph"/>You can further extend this class if you want to store more data along with the authentication to avoid database access. See <a href="../guide/single.html#11 Custom UserDetailsService" class="guide">Custom UserDetailsService</a>.

    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body>
</html>
