<html><head><meta content='text/html; charset=utf-8' http-equiv='Content-type'></meta><title>2.3 PersonAuthority</title><link title='Ref' charset='utf-8' rel='stylesheet' type='text/css' href='../css/main.css' media='screen'></link></head><body><body class='body'>
    The typical approach for mapping the relationship between 'person' and 'authority' is a many-to-many; users have multiple roles, and roles are shared by multiple users. This can be problematic in Grails however since a popular role, e.g. <code>ROLE_USER</code>, will be granted to many users in your application. Since GORM uses collections to manage adding and removing related instances and maps many-to-many relationships bidirectionally, granting a role to a user requires loading all of the existing users who have that role because the collection is a <code>Set</code>. So even though there may be no uniqueness concerns, Hibernate will still load them all to enforce uniqueness. The recommended approach in the plugin is to map a domain class to the join table that manages the many-to-many, and using that to grant and revoke roles to users.<p class='paragraph'></p>Like the other domain classes, this will be generated for you, so you don't need to deal with the details of mapping it. Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>User</code> and <code>Role</code> as your class names, you'll generate this class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p><span class='java-keyword'>import</span> org.apache.commons.lang.builder.HashCodeBuilder<p class='paragraph'></p>class UserRole <span class='java-keyword'>implements</span> Serializable {<p class='paragraph'></p>   User user
   Role role<p class='paragraph'></p><span class='java-object'>boolean</span> equals(other) {
      <span class='java-keyword'>if</span> (!(other <span class='java-keyword'>instanceof</span> UserRole)) {
         <span class='java-keyword'>return</span><span class='java-keyword'>false</span>
      }<p class='paragraph'></p>      other.user?.id == user?.id &amp;&amp;
         other.role?.id == role?.id
   }<p class='paragraph'></p><span class='java-object'>int</span> hashCode() {
      def builder = <span class='java-keyword'>new</span> HashCodeBuilder()
      <span class='java-keyword'>if</span> (user) builder.append(user.id)
      <span class='java-keyword'>if</span> (role) builder.append(role.id)
      builder.toHashCode()
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole get(<span class='java-object'>long</span> userId, <span class='java-object'>long</span> roleId) {
      find 'from UserRole where user.id=:userId and role.id=:roleId',
         [userId: userId, roleId: roleId]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole create(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      <span class='java-keyword'>new</span> UserRole(user: user, role: role).save(flush: flush, insert: <span class='java-keyword'>true</span>)
   }<p class='paragraph'></p><span class='java-keyword'>static</span><span class='java-object'>boolean</span> remove(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      UserRole instance = UserRole.findByUserAndRole(user, role)
      instance ? instance.delete(flush: flush) : <span class='java-keyword'>false</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> void removeAll(User user) {
      executeUpdate 'DELETE FROM UserRole WHERE user=:user', [user: user]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      id composite: ['role', 'user']
      version <span class='java-keyword'>false</span>
   }
}</pre></div><p class='paragraph'></p>The helper methods make it easy to grant or revoke roles. Assuming you've already loaded a user and a role, you grant the role to the user with<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.create user, role</pre></div><p class='paragraph'></p>or using the 3-paramter version to trigger a flush:<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.create user, role, <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>Revoking a role is similar:<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.revoke user, role</pre></div><p class='paragraph'></p>or<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.revoke user, role, <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>The class name is the only configurable attribute:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr></table><p class='paragraph'></p>
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body></html>