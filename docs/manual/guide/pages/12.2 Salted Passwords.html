<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>12.2 Salted Passwords</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    The Spring Security plugin uses encrypted passwords and a digest algorithm that you specify. For enhanced protection against dictionary attacks, you should use a salt in addition to digest encryption.<p class="paragraph"/>There are two approaches to using salted passwords in the plugin - defining a field in the <code>UserDetails</code> class to access by reflection, or by directly implementing <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/dao/SaltSource.html" target="blank">SaltSource</a> yourself.<p class="paragraph"/><h4>dao.reflectionSaltSourceProperty</h4>
Set the <code>dao.reflectionSaltSourceProperty</code> configuration property:<p class="paragraph"/><div class="code"><pre>grails.plugins.springsecurity.dao.reflectionSaltSourceProperty = 'username'</pre></div><p class="paragraph"/>This property belongs to the <code>UserDetails</code> class. By default it is an instance of <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code>, which extends the standard Spring Security <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html" target="blank">User class</a> and not your 'person' domain class. This limits the available fields unless you use a <a href="../guide/single.html#11 Custom UserDetailsService" class="guide">custom <code>UserDetailsService</code></a>.<p class="paragraph"/>As long as the username does not change, this approach works well for the salt. If you choose a property that the user can change, the user cannot log in again after changing it unless you re-encrypt the password with the new value. So it's best to use a property that doesn't change.<p class="paragraph"/>Another option is to generate a random salt when creating users and store this in the database by adding a new field to the 'person' class. This approach requires a custom <code>UserDetailsService</code> because you need a custom <code>UserDetails</code> implementation that also has a 'salt' property, but this is more flexible and works in cases where users can change their username.<p class="paragraph"/><h4>SystemWideSaltSource and Custom SaltSource</h4><p class="paragraph"/>Spring Security supplies a simple <code>SaltSource</code> implementation, <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/dao/SystemWideSaltSource.html" target="blank">SystemWideSaltSource</a>, which uses the same salt for each user. It's less robust than using a different value for each user but still better than no salt at all.<p class="paragraph"/>An example override of the salt source bean using SystemWideSaltSource would look like this:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.security.authentication.dao.SystemWideSaltSource
beans = &#123;
   saltSource(SystemWideSaltSource) &#123;
      systemWideSalt = 'the_salt_value'
   &#125;
&#125;</pre></div><p class="paragraph"/>To have full control over the process, you can implement the <code>SaltSource</code> interface and replace the plugin's implementation with your own by defining a bean in <code>grails-app/conf/spring/resources.groovy</code> with the name <code>saltSource</code>:<p class="paragraph"/><div class="code"><pre>beans = &#123;
   saltSource(com.foo.bar.MySaltSource) &#123;
      // set properties
   &#125;
&#125;</pre></div><p class="paragraph"/><h4>Encrypting Passwords</h4>
Regardless of the implementation, you need to be aware of what value to use for a salt when creating or updating users, for example, in a <code>UserController</code>'s <code>save</code> or <code>update</code> action. When encrypting the password, you use the two-parameter version of <code>springSecurityService.encodePassword()</code>:<p class="paragraph"/><div class="code"><pre>class UserController &#123;<p class="paragraph"/>   def springSecurityService<p class="paragraph"/>   def save = &#123;
      def userInstance = <span class="java&#45;keyword">new</span> User(params)
      userInstance.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      <span class="java&#45;keyword">if</span> (!userInstance.save(flush: <span class="java&#45;keyword">true</span>)) &#123;
         render view: 'create', model: &#91;userInstance: userInstance&#93;
         <span class="java&#45;keyword">return</span>
      &#125;<p class="paragraph"/>      flash.message = <span class="java&#45;quote">"The user was created"</span>
      redirect action: show, id: userInstance.id
   &#125;<p class="paragraph"/>   def update = &#123;
      def userInstance = User.get(params.id)<p class="paragraph"/>      <span class="java&#45;keyword">if</span> (params.password) &#123;
         params.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      &#125;
      userInstance.properties = params
      <span class="java&#45;keyword">if</span> (!userInstance.save(flush: <span class="java&#45;keyword">true</span>)) &#123;
         render view: 'edit', model: &#91;userInstance: userInstance&#93;
         <span class="java&#45;keyword">return</span>
      &#125;<p class="paragraph"/>      <span class="java&#45;keyword">if</span> (springSecurityService.loggedIn &#38;&#38;
               springSecurityService.principal.username == userInstance.username) &#123;
         springSecurityService.reauthenticate userInstance.username
      &#125;<p class="paragraph"/>      flash.message = <span class="java&#45;quote">"The user was updated"</span>
      redirect action: show, id: userInstance.id
   &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
If you are encoding the password in the User domain class (using <code>beforeInsert</code> and <code>encodePassword</code>) then don't call <code>springSecurityService.encodePassword()</code> in your controller since you'll double-encrypt the password and users won't be able to log in. It's best to encapsulate the password handling logic in the domain class.
</blockquote>

    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body>
</html>
