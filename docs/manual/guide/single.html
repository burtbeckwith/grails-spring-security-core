<html><head><title>spring-security-core 0.2 - Reference Documentation</title><link title='Style' charset='utf-8' rel='stylesheet' type='text/css' href='../css/main.css' media='screen'></link><link title='PDF' charset='utf-8' rel='stylesheet' type='text/css' href='../css/pdf.css' media='print'></link></head><body><body class='body'><div id='header'><div class='images'><br></br><br></br><a target='_blank' href='http://grails.org'><img alt='The Grails Framework' src='../img/grails.png' border='0'></img></a><span style='right:30px; top:20px; position:absolute;'><a target='_top' href='../index.html'>Frames</a> | <a target='_top' href='index.html'>No Frames</a><br></br><br></br><a target='_blank' href='http://springsource.com'><img alt='SpringSource - A Division of VMware' src='../img/springsource-logo.png' border='0'></img></a></span></div><div class='message'>spring-security-core</div><h1>spring-security-core - Reference Documentation</h1><p><strong>Authors:</strong> Burt Beckwith</p><p><strong>Version:</strong> 0.2</p><em></em></div><div id='toc'><h2>Table of Contents</h2><div style='margin-left:0px' class='tocItem'><a href='#1. Introduction'>1. Introduction</a></div><div style='margin-left:10px' class='tocItem'><a href='#1.1 Configuration'>1.1 Configuration</a></div><div style='margin-left:10px' class='tocItem'><a href='#1.2 Migration from the Acegi plugin'>1.2 Migration from the Acegi plugin</a></div><div style='margin-left:10px' class='tocItem'><a href='#1.3 History'>1.3 History</a></div><div style='margin-left:0px' class='tocItem'><a href='#2. Domain Classes'>2. Domain Classes</a></div><div style='margin-left:10px' class='tocItem'><a href='#2.1 Person'>2.1 Person</a></div><div style='margin-left:10px' class='tocItem'><a href='#2.2 Authority'>2.2 Authority</a></div><div style='margin-left:10px' class='tocItem'><a href='#2.3 PersonAuthority'>2.3 PersonAuthority</a></div><div style='margin-left:10px' class='tocItem'><a href='#2.4 Requestmap'>2.4 Requestmap</a></div><div style='margin-left:0px' class='tocItem'><a href='#3. Securing URLs'>3. Securing URLs</a></div><div style='margin-left:10px' class='tocItem'><a href='#3.1 Annotations'>3.1 Annotations</a></div><div style='margin-left:10px' class='tocItem'><a href='#3.2 Config.groovy'>3.2 Config.groovy</a></div><div style='margin-left:10px' class='tocItem'><a href='#3.3 Requestmap'>3.3 Requestmap</a></div><div style='margin-left:0px' class='tocItem'><a href='#4. Helper Classes'>4. Helper Classes</a></div><div style='margin-left:10px' class='tocItem'><a href='#4.1. Security Tags'>4.1. Security Tags</a></div><div style='margin-left:10px' class='tocItem'><a href='#4.2. SpringSecurityService'>4.2. SpringSecurityService</a></div><div style='margin-left:10px' class='tocItem'><a href='#4.3. SpringSecurityUtils'>4.3. SpringSecurityUtils</a></div><div style='margin-left:0px' class='tocItem'><a href='#5. Events'>5. Events</a></div><div style='margin-left:0px' class='tocItem'><a href='#6. Configuration'>6. Configuration</a></div><div style='margin-left:0px' class='tocItem'><a href='#7. Custom UserDetailsService'>7. Custom UserDetailsService</a></div><div style='margin-left:0px' class='tocItem'><a href='#8. Ajax Authentication'>8. Ajax Authentication</a></div><div style='margin-left:0px' class='tocItem'><a href='#9. Tutorials'>9. Tutorials</a></div><div style='margin-left:10px' class='tocItem'><a href='#9.1. Using Controller annotations to secure URLs'>9.1. Using Controller annotations to secure URLs</a></div><div style='margin-left:0px' class='tocItem'><a href='#10. Extending and configuring the plugin'>10. Extending and configuring the plugin</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.1. Filters'>10.1. Filters</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.2. Basic and Digest Auth'>10.2. Basic and Digest Auth</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.3. Switch User'>10.3. Switch User</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.4. Session Fixation'>10.4. Session Fixation</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.5. Salted passwords'>10.5. Salted passwords</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.6. Certificate (X509) login'>10.6. Certificate (X509) login</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.7. Channel security'>10.7. Channel security</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.8. IP Address Restrictions'>10.8. IP Address Restrictions</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.9. Logout Handlers'>10.9. Logout Handlers</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.10. Voters'>10.10. Voters</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.11. Authentication Providers'>10.11. Authentication Providers</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.12. Hierarchical Roles'>10.12. Hierarchical Roles</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.13. Account Locking and Forcing Password Change'>10.13. Account Locking and Forcing Password Change</a></div><div style='margin-left:10px' class='tocItem'><a href='#10.13. Remember-me'>10.13. Remember-me</a></div></div><div id='content'><h1><a name='1. Introduction'>1. Introduction</a></h1>The Spring Security plugin simplifies the work involved in integrating <a target='blank' href='http://static.springsource.org/spring-security/site/index.html'>Spring Security</a> (formerly called Acegi Security) into Grails applications. Spring Security versions 2 and 3 have made configuration a lot easier than it used to be with Acegi, but it's still a somewhat complex process. The plugin takes an approach similar to Grails in that it provides sensible defaults with many configuration options for customization. Nearly everything is configurable or replaceable in the plugin and in Spring Security itself (Spring Security makes extensive use of interfaces) so you can easily make whatever changes you need to support various options.<p class='paragraph'></p>The plugin handles the steps required to register filters in <code>web.xml</code> for you, and also configures the Spring beans in the application context that implement various pieces of functionality. In addition, you don't need to deal with figuring out which jar files to use since that's handled by Ivy. So all you need to do is install the plugin, run the initialization script, and make any required configuration changes in <code>Config.groovy</code>.<p class='paragraph'></p>One goal of the plugin is that you shouldn't need to know much about Spring Security to use it, but it can be helpful to understand the underlying implementation, so refer to <a target='blank' href='http://static.springsource.org/spring-security/site/reference.html'>the documentation</a> if something doesn't make sense.<p class='paragraph'></p><h4>Getting started</h4><p class='paragraph'></p>See the <a class='guide' href='../guide/single.html#9. Tutorials'>tutorials</a> section for details on getting started.<p class='paragraph'></p><h2><a name='1.1 Configuration'>1.1 Configuration</a></h2>The plugin is highly configurable, but hopefully most of the default settings should be fine. If you need to override a property, you can do that under  <code>grails-app/conf/Config.groovy</code>. The earlier Acegi plugin used its own configuration file, <code>SecurityConfig.groovy</code> but this plugin maintains its configuration in the standard <code>Config.groovy</code> file. This enables environment-specific configuration, e.g. if you want less restrictive security rules when developing than when you deploy to production. Like any environment-specific config parameters, just wrap them in an <code>environments</code> block.<p class='paragraph'></p><blockquote class='note'>
Note that the plugin's configuration values all start with <code>grails.plugins.springsecurity</code> to keep them separate from similarly named options in Grails or other plugins. In the documentation if you see an attribute such as <code>password.algorithm</code> remember that this would be specified as<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.password.algorithm='SHA-512'</pre></div><p class='paragraph'></p>in <code>Config.groovy</code></blockquote><p class='paragraph'></p>See <a class='guide' href='../guide/single.html#6. Configuration'>Chapter 6</a> for a detailed discussion about the various general configuration options and <a class='guide' href='../guide/single.html#10. Extending and configuring the plugin'>Chapter 10</a> for options for specific features.
<h2><a name='1.2 Migration from the Acegi plugin'>1.2 Migration from the Acegi plugin</a></h2>This plugin is a successor to the original plugin that provided support for Spring Security, the <a target='blank' href='http://grails.org/plugin/acegi/'>Acegi plugin</a>. It's a new plugin that doesn't depend on that plugin but there are many similarities, so migrating is fairly straightforward.<p class='paragraph'></p><h4>Core differences</h4><p class='paragraph'></p>The Spring Security plugin retains many of the core features of the Acegi plugin:
<ul class='star'><li>form-based authentication</li><li>storing users, roles, and optionally requestmaps in the database and accessing via domain classes</li><li>guarding URLs with annotations, requestmap domain class, or static configuration</li><li>security tags</li><li>security service</li><li>security events</li><li>Ajax login</li><li>Basic auth</li><li>Switch User</li><li>Channel security</li><li>IP Address Restrictions</li></ul><p class='paragraph'></p>and in addition adds several new features:
<ul class='star'><li>Digest Auth</li><li>Session Fixation</li><li>Salted passwords</li><li>Certificate (x509) login</li><li>Hierarchical Roles</li><li>Account Locking and Forcing Password Change</li></ul><p class='paragraph'></p>There are a few core concepts that have changed and will require configuration changes in your application:
<table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th>&#xa0;</th><th><strong class='bold'>Spring Security plugin</strong></th><th><strong class='bold'>Acegi plugin</strong></th></tr><tr class='table-odd'><td>enabled by default</td><td><code>true</code></td><td><code>false</code></td></tr><tr class='table-even'><td>cache UserDetails by default</td><td><code>false</code></td><td><code>true</code></td></tr><tr class='table-odd'><td>configuration location</td><td><code>grails-app/conf/Config.groovy</code></td><td><code>grails-app/conf/SecurityConfig.groovy</code></td></tr><tr class='table-even'><td>security service</td><td><code>springSecurityService</code></td><td><code>authenticateService</code></td></tr></table><p class='paragraph'></p>There are features that are not included but which will be available in secondary plugins that will extend and depend on the core plugin:
<ul class='star'><li>Facebook</li><li>OpenID</li><li>LDAP</li><li>CAS</li><li>NTLM</li><li>Kerberos</li><li>User registration</li></ul><p class='paragraph'></p><h4>Configuration differences</h4><p class='paragraph'></p>This table summarizes the configuration attribute names in both plugins:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Acegi plugin</strong></th><th><strong class='bold'>Spring Security plugin</strong></th></tr><tr class='table-odd'><td>active</td><td>active</td></tr><tr class='table-even'><td>loginUserDomainClass</td><td>userLookup.userDomainClassName</td></tr><tr class='table-odd'><td>userName</td><td>userLookup.usernamePropertyName</td></tr><tr class='table-even'><td>enabled</td><td>userLookup.enabledPropertyName</td></tr><tr class='table-odd'><td>password</td><td>userLookup.passwordPropertyName</td></tr><tr class='table-even'><td>relationalAuthorities</td><td>userLookup.authoritiesPropertyName</td></tr><tr class='table-odd'><td>getAuthoritiesMethod</td><td>N/A</td></tr><tr class='table-even'><td>authorityDomainClass</td><td>authority.className</td></tr><tr class='table-odd'><td>authorityField</td><td>authority.nameField</td></tr><tr class='table-even'><td>authenticationFailureUrl</td><td>failureHandler.defaultFailureUrl</td></tr><tr class='table-odd'><td>ajaxAuthenticationFailureUrl</td><td>failureHandler.ajaxAuthFailUrl</td></tr><tr class='table-even'><td>defaultTargetUrl</td><td>successHandler.defaultTargetUrl</td></tr><tr class='table-odd'><td>alwaysUseDefaultTargetUrl</td><td>successHandler.alwaysUseDefault</td></tr><tr class='table-even'><td>filterProcessesUrl</td><td>apf.filterProcessesUrl</td></tr><tr class='table-odd'><td>key</td><td>anon.key</td></tr><tr class='table-even'><td>userAttribute</td><td>anon.userAttribute</td></tr><tr class='table-odd'><td>loginFormUrl</td><td>auth.loginFormUrl</td></tr><tr class='table-even'><td>forceHttps</td><td>auth.forceHttps</td></tr><tr class='table-odd'><td>ajaxLoginFormUrl</td><td>auth.ajaxLoginFormUrl</td></tr><tr class='table-even'><td>afterLogoutUrl</td><td>logout.afterLogoutUrl</td></tr><tr class='table-odd'><td>errorPage</td><td>adh.errorPage</td></tr><tr class='table-even'><td>ajaxErrorPage</td><td>adh.ajaxErrorPage</td></tr><tr class='table-odd'><td>ajaxHeader</td><td>ajaxHeader</td></tr><tr class='table-even'><td>algorithm</td><td>password.algorithm</td></tr><tr class='table-odd'><td>encodeHashAsBase64</td><td>password.encodeHashAsBase64</td></tr><tr class='table-even'><td>cookieName</td><td>rememberMe.cookieName</td></tr><tr class='table-odd'><td>alwaysRemember</td><td>rememberMe.alwaysRemember</td></tr><tr class='table-even'><td>tokenValiditySeconds</td><td>rememberMe.tokenValiditySeconds</td></tr><tr class='table-odd'><td>parameter</td><td>rememberMe.parameter</td></tr><tr class='table-even'><td>rememberMeKey</td><td>rememberMe.key</td></tr><tr class='table-odd'><td>useLogger</td><td>registerLoggerListener</td></tr><tr class='table-even'><td>useRequestMapDomainClass</td><td>securityConfigType = <code>SecurityConfigType.Requestmap</code></td></tr><tr class='table-odd'><td>requestMapClass</td><td>requestMap.className</td></tr><tr class='table-even'><td>requestMapPathField</td><td>requestMap.urlField</td></tr><tr class='table-odd'><td>requestMapConfigAttributeField</td><td>requestMap.configAttributeField</td></tr><tr class='table-even'><td>useControllerAnnotations</td><td>securityConfigType = <code>SecurityConfigType.Annotation</code></td></tr><tr class='table-odd'><td>controllerAnnotationsMatcher</td><td>controllerAnnotations.matcher</td></tr><tr class='table-even'><td>controllerAnnotationsMatchesLowercase</td><td>controllerAnnotations.lowercase</td></tr><tr class='table-odd'><td>controllerAnnotationStaticRules</td><td>controllerAnnotations.staticRules</td></tr><tr class='table-even'><td>controllerAnnotationsRejectIfNoRule</td><td>rejectIfNoRule</td></tr><tr class='table-odd'><td>requestMapString</td><td>N/A - securityConfigType = <code>SecurityConfigType.InterceptUrlMap</code> is very similar</td></tr><tr class='table-even'><td>realmName</td><td>basic.realmName</td></tr><tr class='table-odd'><td>basicProcessingFilter</td><td>useBasicAuth</td></tr><tr class='table-even'><td>switchUserProcessingFilter</td><td>useSwitchUserFilter</td></tr><tr class='table-odd'><td>swswitchUserUrl</td><td>switchUser.switchUserUrl</td></tr><tr class='table-even'><td>swexitUserUrl</td><td>switchUser.exitUserUrl</td></tr><tr class='table-odd'><td>swtargetUrl</td><td>switchUser.targetUrl</td></tr><tr class='table-even'><td>useMail</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-odd'><td>mailHost</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-even'><td>mailUsername</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-odd'><td>mailPassword</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-even'><td>mailProtocol</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-odd'><td>mailFrom</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-even'><td>mailPort</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-odd'><td>defaultRole</td><td>N/A - registration will be supported in the UI plugin</td></tr><tr class='table-even'><td>useOpenId</td><td>N/A - will be supported in the OpenID plugin</td></tr><tr class='table-odd'><td>openIdNonceMaxSeconds</td><td>N/A - will be supported in the OpenID plugin</td></tr><tr class='table-even'><td>useLdap</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapRetrieveGroupRoles</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapRetrieveDatabaseRoles</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapSearchSubtree</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapGroupRoleAttribute</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapPasswordAttributeName</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapServer</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapManagerDn</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapManagerPassword</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapSearchBase</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapSearchFilter</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapGroupSearchBase</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>ldapGroupSearchFilter</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-odd'><td>ldapUsePassword</td><td>N/A - will be supported in the LDAP plugin</td></tr><tr class='table-even'><td>useKerberos</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>kerberosLoginConfigFile</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-even'><td>kerberosRealm</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>kerberosKdc</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-even'><td>kerberosRetrieveDatabaseRoles</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>useHttpSessionEventPublisher</td><td>useHttpSessionEventPublisher</td></tr><tr class='table-even'><td>cacheUsers</td><td>cacheUsers</td></tr><tr class='table-odd'><td>useCAS</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.casServer</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.casServerPort</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.casServerSecure</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.localhostSecure</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.failureURL</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.defaultTargetURL</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.fullLoginURL</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.fullServiceURL</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.authenticationProviderKey</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.userDetailsService</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.sendRenew</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>cas.proxyReceptorUrl</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-even'><td>cas.filterProcessesUrl</td><td>N/A - will be supported in the CAS plugin</td></tr><tr class='table-odd'><td>useNtlm</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-even'><td>ntlm.stripDomain</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>ntlm.retryOnAuthFailure</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-even'><td>ntlm.forceIdentification</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>ntlm.defaultDomain</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-even'><td>ntlm.netbiosWINS</td><td>N/A - will be supported in a secondary plugin</td></tr><tr class='table-odd'><td>httpPort</td><td>portMapper.httpPort</td></tr><tr class='table-even'><td>httpsPort</td><td>portMapper.httpsPort</td></tr><tr class='table-odd'><td>secureChannelDefinitionSource</td><td>N/A, use secureChannel.definition</td></tr><tr class='table-even'><td>channelConfig</td><td>secureChannel.definition</td></tr><tr class='table-odd'><td>ipRestrictions</td><td>ipRestrictions</td></tr><tr class='table-even'><td>useFacebook</td><td>N/A - will be supported in the Facebook plugin</td></tr><tr class='table-odd'><td>facebook.filterProcessesUrl</td><td>N/A - will be supported in the Facebook plugin</td></tr><tr class='table-even'><td>facebook.authenticationUrlRoot</td><td>N/A - will be supported in the Facebook plugin</td></tr><tr class='table-odd'><td>facebook.apiKey</td><td>N/A - will be supported in the Facebook plugin</td></tr><tr class='table-even'><td>facebook.secretKey</td><td>N/A - will be supported in the Facebook plugin</td></tr></table><p class='paragraph'></p><h4>Script differences</h4><p class='paragraph'></p>In the Acegi plugin you run the <code>create-auth-domains</code> script to initialize the plugin. This creates <code>grails-app/conf/SecurityConfig.groovy</code> to allow configuration customization, and creates the User, Role, and Requestmap domain classes, along with the Login and Logout controllers and views. In addition there's the <code>generate-manager</code> script which creates CRUD pages for the domain classes (earlier version of Grails didn't scaffold many-to-many relationships well, so these GSPs were necessary), and a <code>generate-registration</code> script which installs a basic user registration controller.<p class='paragraph'></p>In the Spring Security plugin, there's just one script, <a class='Scripts' href='../ref/Scripts/s2-quickstart.html'>s2-quickstart</a>. It's most similar to <code>create-auth-domains</code> since it creates domain classes and login/logout controllers, but it appends to <code>grails-app/conf/Config.groovy</code> instead of creating a standalone configuration file. There's no equivalent to <code>generate-manager</code> or <code>generate-registration</code> since there will be an optional UI plugin that will generate domain class management screens, an admin console, and forgot password and registration workflows. If you want to create your own CRUD pages you can use the standard Grails <code>generate-all</code> script. Various sections of this documentation discusses the changes you'll need to make in the generated source files, e.g. encrypting passwords before saving or updating a user.<p class='paragraph'></p><h4>domainClass</h4><p class='paragraph'></p>The Acegi plugin extended the <code>UserDetails</code> instance and added an accessor for the person domain class instance that was used to populate the <code>UserDetails</code>. This is convenient because since the <code>Authentication</code> is kept in the HTTP session and the <code>UserDetails</code> is attached to that, so it was easy to access non-security data such as full name, email, etc. without hitting the database.<p class='paragraph'></p>This caused problems however. One is that if the domain class has a lot of data, you increase the size of the session payload and this is even worse if you have clustered sessions. Further, any lazy-loaded collections would fail to load after retrieving the person from the session since it would have become a detached Hibernate object. This caused confusion but is easily fixed, either by calling person.attach() or by reloading by id, i.e.<p class='paragraph'></p><div class='code'><pre>def userDetails = authenticateService.principal()
def person = userDetails.domainClass
person = Person.get(person.id)</pre></div><p class='paragraph'></p>but then the person has essentially become a very large wrapper around its primary key since that's the real data you're storing.<p class='paragraph'></p>So the approach that this plugin takes is to not store the domain class but instead store the id so you can retrieve the person easily:<p class='paragraph'></p><div class='code'><pre>def userDetails = springSecurityService.principal
person = Person.get(userDetails.id)</pre></div><p class='paragraph'></p>This works because the <code>UserDetails</code> implementation is an instance of <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code> which extends the standard Spring Security <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html'>User</a> and adds a <code>getId()</code> method.<p class='paragraph'></p>You're encouraged to further extend this class if you want to store more data along with the authentication to avoid database access - see <a class='guide' href='../guide/single.html#7. Custom UserDetailsService'>Chapter 7</a> for details on this.<p class='paragraph'></p><h2><a name='1.3 History'>1.3 History</a></h2><h4>History</h4><ul class='star'><li>May 2, 2010</li><ul class='star'><li>0.2 release</li></ul><li>April 27, 2010</li><ul class='star'><li>initial 0.1 release</li></ul></ul><p class='paragraph'></p><h4>Authors</h4><p class='paragraph'></p>Burt Beckwith<p class='paragraph'></p><h4>Acknowledgements</h4><p class='paragraph'></p>This plugin is based on work done for the <a target='blank' href='http://grails.org/plugin/acegi/'>Acegi</a> plugin by Tsuyoshi Yamamoto.<p class='paragraph'></p><h1><a name='2. Domain Classes'>2. Domain Classes</a></h1>The plugin uses regular Grails domain classes to access its required data. At a minimum you'll need a 'person' and an 'authority' domain class. In addition, if you want to store URL&lt;-&gt;Role mappings in the database (this is one of multiple approaches for defining the mappings) then you'll need a 'requestmap' domain class, and if you use the recommended approach for mapping the many-to-many relationship between 'person' and 'authority' then you'll also need a domain class to map the join table.<p class='paragraph'></p>The <a class='Scripts' href='../ref/Scripts/s2-quickstart.html'>s2-quickstart</a> script creates initial domain classes for you. You specify the package and class names, and it creates the corresponding domain classes. After that you can customize them as you like. You can add as many other fields, methods, etc. as you like, as long as the core security-related functionality remains.<p class='paragraph'></p><h2><a name='2.1 Person'>2.1 Person</a></h2>Spring Security uses an <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html'>Authentication</a> object to determine whether the current user has the right to perform a secured action, i.e. accessing a URL, manipulate a secured domain object, access a secured method, etc. This is created during login, and typically there's overlap between the need for the data that's required to populate the authentication (username, password, granted authorities, etc.) and the need to represent a user in the application in ways that aren't related to security. The mechanism for populating the authentication is completely pluggable in Spring Security - you only need to provide an implementation of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetailsService.html'>UserDetailsService</a> and implement its one method, <code>loadUserByUsername()</code>.<p class='paragraph'></p>You can easily <a class='guide' href='../guide/single.html#7. Custom UserDetailsService'>plug in your own implementation</a> but by default the plugin uses a Grails 'person' domain class to manage this data. The class name and package can be named whatever you want, and so can the fields. By default the class name is <code>Person</code>, and <code>username</code>, <code>enabled</code>, <code>password</code> are the default names of the required properties. In addition it's expected that there is an <code>authorities</code> property to retrieve roles; this can either be a public field or a <code>getAuthorities()</code> method, and it can either be defined via a traditional GORM many-to-many or via a custom mapping (more HERE).<p class='paragraph'></p>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>User</code> as your class name, you'll generate this class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p>class User {<p class='paragraph'></p><span class='java-object'>String</span> username
   <span class='java-object'>String</span> password
   <span class='java-object'>boolean</span> enabled
   <span class='java-object'>boolean</span> accountExpired
   <span class='java-object'>boolean</span> accountLocked
   <span class='java-object'>boolean</span> passwordExpired<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      username blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
      password blank: <span class='java-keyword'>false</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      password column: '`password`'
   }<p class='paragraph'></p>   Set&lt;Role&gt; getAuthorities() {
      UserRole.findAllByUser(<span class='java-keyword'>this</span>).collect { it.role } as Set
   }
}</pre></div><p class='paragraph'></p>and of course if you like you can add other properties, e.g. <code>email</code>, <code>firstName</code>, <code>lastName</code>, and convenience methods, etc.:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p>class User {<p class='paragraph'></p><span class='java-object'>String</span> username
   <span class='java-object'>String</span> password
   <span class='java-object'>boolean</span> enabled
   <span class='java-object'>String</span> email
   <span class='java-object'>String</span> firstName
   <span class='java-object'>String</span> lastName<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      username blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
      password blank: <span class='java-keyword'>false</span>
   }<p class='paragraph'></p>   Set&lt;Role&gt; getAuthorities() {
      UserRole.findAllByUser(<span class='java-keyword'>this</span>).collect { it.role } as Set
   }<p class='paragraph'></p>   def someMethod {
      &#x2026;
   }
}</pre></div><p class='paragraph'></p>The <code>getAuthorities()</code> method is analagous to defining <code>static hasMany = [authorities: Authority]</code> in a traditional many-to-many mapping. This way <code>GormUserDetailsService</code> can call <code>user.authorities</code> during login to retrieve the roles without the overhead of a bidirectional many-to-many mapping.<p class='paragraph'></p>The class and property names are configurable using these configuration attributes:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>userLookup.userDomainClassName</td><td>'Person'</td><td>User class name</td></tr><tr class='table-even'><td>userLookup.usernamePropertyName</td><td>'username'</td><td>User class username field</td></tr><tr class='table-odd'><td>userLookup.passwordPropertyName</td><td>'password'</td><td>User class password field</td></tr><tr class='table-even'><td>userLookup.authoritiesPropertyName</td><td>'authorities'</td><td>User class role collection field</td></tr><tr class='table-odd'><td>userLookup.enabledPropertyName</td><td>'enabled'</td><td>User class enabled field</td></tr><tr class='table-even'><td>userLookup.accountExpiredPropertyName</td><td>'accountExpired'</td><td>User class account expired field</td></tr><tr class='table-odd'><td>userLookup.accountLockedPropertyName</td><td>'accountLocked'</td><td>User class account locked field</td></tr><tr class='table-even'><td>userLookup.passwordExpiredPropertyName</td><td>'passwordExpired'</td><td>User class password expired field</td></tr><tr class='table-odd'><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr></table><p class='paragraph'></p><h2><a name='2.2 Authority'>2.2 Authority</a></h2>The plugin also requires an 'authority' class to represent a user's role(s) in the application, used in general to restrict URLs to users who have been assigned the required access rights. A user can have multiple roles to indicate various access rights in the application, and should have at least one. A basic user who can only access non-restricted resources but can still authenticate is a bit unusual. Spring Security will for the most part function fine if a user has no granted authorities, but will fail in a few places that assume one or more. So if a user authenticates successfully but has no granted roles, the plugin will grant the user a 'virtual' role, <code>ROLE_NO_ROLES</code> to work around this limitation. This way the user will satisfy all of Spring Security's requirements but not be able to do anything since you wouldn't associate any secure resources with this role.<p class='paragraph'></p>Like the 'person' class, the 'authority' class has a default name, <code>Authority</code>, and a default name for its one required property, <code>authority</code>.
If you want to use an existing domain class, it just has to have a property for name. As with the name of the class, the names of the properties can be whatever you want - they're specified in <code>grails-app/conf/Config.groovy</code>.<p class='paragraph'></p>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>Role</code> as your class name, you'll generate this class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p>class Role {<p class='paragraph'></p><span class='java-object'>String</span> authority<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      cache <span class='java-keyword'>true</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      authority blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
   }
}</pre></div><p class='paragraph'></p>The class and property names are configurable using these configuration attributes:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>authority.className</td><td>'Authority'</td><td>Role class name</td></tr><tr class='table-even'><td>authority.nameField</td><td>'authority'</td><td>Role class role name field</td></tr></table><p class='paragraph'></p><h2><a name='2.3 PersonAuthority'>2.3 PersonAuthority</a></h2>The typical approach for mapping the relationship between 'person' and 'authority' is a many-to-many; users have multiple roles, and roles are shared by multiple users. This can be problematic in Grails however since a popular role, e.g. <code>ROLE_USER</code>, will be granted to many users in your application. Since GORM uses collections to manage adding and removing related instances and maps many-to-many relationships bidirectionally, granting a role to a user requires loading all of the existing users who have that role because the collection is a <code>Set</code>. So even though there may be no uniqueness concerns, Hibernate will still load them all to enforce uniqueness. The recommended approach in the plugin is to map a domain class to the join table that manages the many-to-many, and using that to grant and revoke roles to users.<p class='paragraph'></p>Like the other domain classes, this will be generated for you, so you don't need to deal with the details of mapping it. Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>User</code> and <code>Role</code> as your class names, you'll generate this class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p><span class='java-keyword'>import</span> org.apache.commons.lang.builder.HashCodeBuilder<p class='paragraph'></p>class UserRole <span class='java-keyword'>implements</span> Serializable {<p class='paragraph'></p>   User user
   Role role<p class='paragraph'></p><span class='java-object'>boolean</span> equals(other) {
      <span class='java-keyword'>if</span> (!(other <span class='java-keyword'>instanceof</span> UserRole)) {
         <span class='java-keyword'>return</span><span class='java-keyword'>false</span>
      }<p class='paragraph'></p>      other.user?.id == user?.id &amp;&amp;
         other.role?.id == role?.id
   }<p class='paragraph'></p><span class='java-object'>int</span> hashCode() {
      def builder = <span class='java-keyword'>new</span> HashCodeBuilder()
      <span class='java-keyword'>if</span> (user) builder.append(user.id)
      <span class='java-keyword'>if</span> (role) builder.append(role.id)
      builder.toHashCode()
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole get(<span class='java-object'>long</span> userId, <span class='java-object'>long</span> roleId) {
      find 'from UserRole where user.id=:userId and role.id=:roleId',
         [userId: userId, roleId: roleId]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole create(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      <span class='java-keyword'>new</span> UserRole(user: user, role: role).save(flush: flush, insert: <span class='java-keyword'>true</span>)
   }<p class='paragraph'></p><span class='java-keyword'>static</span><span class='java-object'>boolean</span> remove(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      UserRole instance = UserRole.findByUserAndRole(user, role)
      instance ? instance.delete(flush: flush) : <span class='java-keyword'>false</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> void removeAll(User user) {
      executeUpdate 'DELETE FROM UserRole WHERE user=:user', [user: user]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      id composite: ['role', 'user']
      version <span class='java-keyword'>false</span>
   }
}</pre></div><p class='paragraph'></p>The helper methods make it easy to grant or revoke roles. Assuming you've already loaded a user and a role, you grant the role to the user with<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.create user, role</pre></div><p class='paragraph'></p>or using the 3-paramter version to trigger a flush:<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.create user, role, <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>Revoking a role is similar:<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.revoke user, role</pre></div><p class='paragraph'></p>or<p class='paragraph'></p><div class='code'><pre>User user = &#x2026;
Role role = &#x2026;
UserRole.revoke user, role, <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>The class name is the only configurable attribute:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr></table><p class='paragraph'></p><h2><a name='2.4 Requestmap'>2.4 Requestmap</a></h2>This class is optionally used to store request mapping entries in the database instead of defining them with annotations or in <code>Config.groovy</code>. This has the advantage of being configurable at runtime; you can add, remove and edit rules without restarting your application.<p class='paragraph'></p>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>Requestmap</code> as your class name, you'll generate this class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p>class Requestmap {<p class='paragraph'></p><span class='java-object'>String</span> url
   <span class='java-object'>String</span> configAttribute<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      cache <span class='java-keyword'>true</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      url blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
      configAttribute blank: <span class='java-keyword'>false</span>
   }
}</pre></div><p class='paragraph'></p>The class and property names are configurable using these configuration attributes:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>requestMap.className</td><td>'Requestmap'</td><td>requestmap class name</td></tr><tr class='table-even'><td>requestMap.urlField</td><td>'url'</td><td>URL pattern field name</td></tr><tr class='table-odd'><td>requestMap.configAttributeField</td><td>'configAttribute'</td><td>authority pattern field name</td></tr></table><p class='paragraph'></p>See <a class='guide' href='../guide/single.html#3.3 Requestmap'>this section</a> on URL mapping for details on using Requestmap entries to guard URLs.
<h1><a name='3. Securing URLs'>3. Securing URLs</a></h1>There are three ways to configure request mappings to secure application URLs. The goal is to create a mapping of URL patterns to the roles required to access those URLs. Use whichever approach makes the most sense for you. The three approaches are:
<ul class='star'><li><code>@Secured</code> annotations</li><li>a simple Map in <code>Config.groovy</code></li><li><code>Requestmap</code> domain class instances stored in the database</li></ul><p class='paragraph'></p>and the default approach is to use annotations. You can only use one method at a time, and it's configured with the <code>securityConfigType</code> attribute; the value has to be an <code>SecurityConfigType</code> enum value.<p class='paragraph'></p>To use annotations, specify <code>SecurityConfigType.Annotation</code> (or leave it unspecified since it's the default):<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> grails.plugins.springsecurity.SecurityConfigType<p class='paragraph'></p>...<p class='paragraph'></p>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.Annotation</pre></div><p class='paragraph'></p>To use the <code>Config.groovy</code> Map, specify <code>SecurityConfigType.InterceptUrlMap</code>:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> grails.plugins.springsecurity.SecurityConfigType<p class='paragraph'></p>...<p class='paragraph'></p>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.InterceptUrlMap</pre></div><p class='paragraph'></p>To use <code>Requestmap</code> entries, specify <code>SecurityConfigType.Requestmap</code>:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> grails.plugins.springsecurity.SecurityConfigType<p class='paragraph'></p>...<p class='paragraph'></p>grails.plugins.springsecurity.securityConfigType = SecurityConfigType.Requestmap</pre></div><p class='paragraph'></p>In addition, you can use a pessimistic 'lockdown' approach if you like. Most applications are mostly public, with some pages only accessible to authenticated users with various roles. Here it makes more sense to leave URLs open by default and restrict access one a case-by-case basis. But if your app is primarily secure, you can deny access to all URLs that don't have an applicable URL-Role configuration.<p class='paragraph'></p>To use the pessimistic approach, add this to <code>grails-app/conf/Config.groovy</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.rejectIfNoRule = <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>and any requested URL that doesn't have a corresponding rule will be denied to all users.<p class='paragraph'></p><h4>URLs and authorities</h4><p class='paragraph'></p>In each approach you configure a mapping for a URL pattern to the role(s) that are required to access those URLs, e.g. <code>/admin/user/**</code> requires <code>ROLE_ADMIN</code>. In addition, you can combine the role(s) with tokens such as IS_AUTHENTICATED_ANONYMOUSLY, IS_AUTHENTICATED_REMEMBERED, and IS_AUTHENTICATED_FULLY. One or more <code>Voter</code>s will process any tokens and enforce a rule based on them:
<ul class='star'><li><code>IS_AUTHENTICATED_ANONYMOUSLY</code></li><ul class='star'><li>signifies that anyone can access this URL; by default the <code>AnonymousAuthenticationFilter</code> ensures that there's an 'anonymous' <code>Authentication</code> with no roles so every user has an authentication, so this token just requires any authentication, even anonymous</li></ul><li><code>IS_AUTHENTICATED_REMEMBERED</code></li><ul class='star'><li>signifies that the user is authenticated via a remember-me cookie or an explicit login</li></ul><li><code>IS_AUTHENTICATED_FULLY</code></li><ul class='star'><li>requires that the user be fully authenticated via an explicit login</li></ul></ul><p class='paragraph'></p><code>IS_AUTHENTICATED_FULLY</code> is useful to implement a security scheme where you allow users to check a remember-me checkbox during login, and auto-authenticate them each time they come back to your site, but require them to login with a password for some parts of the site. For example regular browsing might be allowed and even adding items to a shopping cart with only a cookie, but checking out or viewing purchase history would require an explicit login.<p class='paragraph'></p><h4>Advantages and disadvantages</h4><p class='paragraph'></p>Each approach has its advantages and disadvantages. Annotations and the <code>Config.groovy</code> Map are less flexible since they're configured once in the code and can only be updated by restarting the application (in prod mode anyway). In practice this isn't that serious a concern since for most applications security mappings are unlikely to change at runtime.<p class='paragraph'></p>If you want runtime-configurability then storing <code>Requestmap</code> entries enables this. This allows you to have a core set of rules populated at application startup and to edit, add, and delete them whenever you like. But it separates the security rules from the application code, which is less convenient than having the rules defined in <code>grails-app/conf/Config.groovy</code> or in the applicable controllers using annotations.<p class='paragraph'></p><h4>Some notes</h4><ul class='star'><li>to understand the meaning of <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code>, see the Javadoc for <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/vote/AuthenticatedVoter.html'>AuthenticatedVoter</a></li><li>URLs must be mapped in lowercase if using the <code>Requestmap</code> or <code>grails-app/conf/Config.groovy</code> map approaches, so for example if you have a FooBarController, its urls will be of the form /fooBar/list, /fooBar/create, etc. but these must be mapped as /foobar/, /foobar/list, /foobar/create. This is handled automatically for you if you use annotations.</li></ul><p class='paragraph'></p><h2><a name='3.1 Annotations'>3.1 Annotations</a></h2>The plugin supplies an <code>@Secured</code> annotation that you can use in your controllers to configure which roles are required for which actions.<p class='paragraph'></p>You can define the annotation at the class level, meaning that the specified roles are required for all actions, or at the action level, or both. If the class and an action are annotated then the action annotation values will be used since they're more specific.<p class='paragraph'></p>For example, given this controller:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SecureAnnotatedController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN'])
   def index = {
      render 'you have ROLE_ADMIN'
   }<p class='paragraph'></p>   @Secured(['ROLE_ADMIN', 'ROLE_SUPERUSER'])
   def adminEither = {
      render 'you have ROLE_ADMIN or SUPERUSER'
   }<p class='paragraph'></p>   def anybody = {
      render 'anyone can see <span class='java-keyword'>this</span>'
   }
}</pre></div><p class='paragraph'></p>you'd need to be authenticated and have <code>ROLE_ADMIN</code> to see <code>/myapp/secureAnnotated</code> (or <code>/myapp/secureAnnotated/index</code>) and be authenticated and have <code>ROLE_ADMIN</code> or <code>ROLE_SUPERUSER</code> to see <code>/myapp/secureAnnotated/adminEither</code>. Any user can access <code>/myapp/secureAnnotated/anybody</code>.<p class='paragraph'></p>Quite often most actions in a controller require similar access rules, so you can also define annotations at the class level:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>@Secured(['ROLE_ADMIN'])
class SecureClassAnnotatedController {<p class='paragraph'></p>   def index = {
      render 'index: you have ROLE_ADMIN'
   }<p class='paragraph'></p>   def otherAction = {
      render 'otherAction: you have ROLE_ADMIN'
   }<p class='paragraph'></p>   @Secured(['ROLE_SUPERUSER'])
   def <span class='java-keyword'>super</span> = {
      render '<span class='java-keyword'>super</span>: you have ROLE_SUPERUSER'
   }
}</pre></div><p class='paragraph'></p>Here you'd need to be authenticated and have <code>ROLE_ADMIN</code> to see <code>/myapp/secureClassAnnotated</code> (or <code>/myapp/secureClassAnnotated/index</code>) or <code>/myapp/secureClassAnnotated/otherAction</code>. However you must have <code>ROLE_SUPERUSER</code> to access <code>/myapp/secureClassAnnotated/super</code> - the action-scope annotation overrides the class-scope annotation.<p class='paragraph'></p><h4>controllerAnnotations.staticRules</h4><p class='paragraph'></p>You can also define 'static' mappings that cannot be expressed in the controllers, such as '/<strong class='bold'></strong>' or for JavaScript, CSS, or image URLs. Use the <code>controllerAnnotations.staticRules</code> property, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.controllerAnnotations.staticRules = [
   '/js/admin/**': ['ROLE_ADMIN'],
   '/somePlugin/**': ['ROLE_ADMIN']
]</pre></div><p class='paragraph'></p>In this example we've mapped all URLs associated with 'somePlugin' to <code>ROLE_ADMIN</code>; annotations aren't an option here since you wouldn't want to edit plugin code for a change like this.
<h2><a name='3.2 Config.groovy'>3.2 Config.groovy</a></h2>To use this approach, just define a Map in <code>Config.groovy</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.interceptUrlMap = [
   '/secure/**':    ['ROLE_ADMIN'],
   '/finance/**':   ['ROLE_FINANCE', 'IS_AUTHENTICATED_FULLY'],
   '/js/**':        ['IS_AUTHENTICATED_ANONYMOUSLY'],
   '/css/**':       ['IS_AUTHENTICATED_ANONYMOUSLY'],
   '/images/**':    ['IS_AUTHENTICATED_ANONYMOUSLY'],
   '/*':            ['IS_AUTHENTICATED_ANONYMOUSLY'],
   '/login/**':     ['IS_AUTHENTICATED_ANONYMOUSLY'],
   '/logout/**':    ['IS_AUTHENTICATED_ANONYMOUSLY']
]</pre></div><p class='paragraph'></p>When using this approach, make sure that you order the rules correctly. The first applicable rule is used, so for example if you have a controller that has one set of rules but an action that has stricter access rules, e.g.<p class='paragraph'></p><div class='code'><pre>'/secure/**':              ['ROLE_ADMIN', 'ROLE_SUPERUSER'],
'/secure/reallysecure/**': ['ROLE_SUPERUSER']</pre></div><p class='paragraph'></p>then this would fail - it wouldn't restrict access to <code>/secure/reallysecure/list</code> to a user with <code>ROLE_SUPERUSER</code> since the first URL pattern matches, so the second would be ignored. The correct mapping would be<p class='paragraph'></p><div class='code'><pre>'/secure/reallysecure/**': ['ROLE_SUPERUSER']
'/secure/**':              ['ROLE_ADMIN', 'ROLE_SUPERUSER'],</pre></div><p class='paragraph'></p><h2><a name='3.3 Requestmap'>3.3 Requestmap</a></h2>With this approach you store mapping entries in the database, using the <code>Requestmap</code> domain class. <code>Requestmap</code> has a <code>url</code> property which contains the secured URL pattern and a <code>configAttribute</code> property containing a comma-delimited list of required roles and/or tokens such as <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code>.<p class='paragraph'></p>Creation of <code>Requestmap</code> entries is the same as for any Grails domain class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>new</span> Requestmap(url: '/js/**', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/css/**', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/images/**', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/login/**', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/logout/**', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/*', configAttribute: 'IS_AUTHENTICATED_ANONYMOUSLY').save()
<span class='java-keyword'>new</span> Requestmap(url: '/profile/**', configAttribute: 'ROLE_USER').save()
<span class='java-keyword'>new</span> Requestmap(url: '/admin/**', configAttribute: 'ROLE_ADMIN').save()
<span class='java-keyword'>new</span> Requestmap(url: '/admin/user/**', configAttribute: 'ROLE_SUPERVISOR').save()</pre></div><p class='paragraph'></p>Unlike the <code>Config.groovy</code> Map approach above, you don't need to worry about <code>Requestmap</code> entry order since the plugin calculates the most specific rule that applies to the current request.<p class='paragraph'></p><h4>Requestmap cache</h4><p class='paragraph'></p><code>Requestmap</code> entries are cached for performance, but this has an impact on runtime configurability. If you create, edit, or delete an instance, the cache must be flushed and repopulated to be consistent with the database. You can call <code>springSecurityService.clearCachedRequestmaps()</code> to do this. For example, if you create a <code>RequestmapController</code> the <code>save</code> action should look like this (and the update and delete actions should similarly call <code>clearCachedRequestmaps()</code>):<p class='paragraph'></p><div class='code'><pre>class RequestmapController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   ...<p class='paragraph'></p>   def save = {
      def requestmapInstance = <span class='java-keyword'>new</span> Requestmap(params)
      <span class='java-keyword'>if</span> (!requestmapInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'create', model: [requestmapInstance: requestmapInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p>      springSecurityService.clearCachedRequestmaps()
      flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.created.message', args: [message(code: 'requestmap.label', <span class='java-keyword'>default</span>: 'Requestmap'), requestmapInstance.id])}"</span>
      redirect action: show, id: requestmapInstance.id
   }
}</pre></div><p class='paragraph'></p><h1><a name='4. Helper Classes'>4. Helper Classes</a></h1>The plugin has a few helper classes that you can use in your application to avoid having to deal with the lower-level details of Spring Security.
<h2><a name='4.1. Security Tags'>4.1. Security Tags</a></h2>The plugin comes with a few GSP tags to support conditional display based on whether the user is authenticated, and/or has the required role to perform some action. All of the tags are in the <code>sec</code> namespace and are implemented in <code>grails.plugins.springsecurity.SecurityTagLib</code>.<p class='paragraph'></p><h4>ifLoggedIn</h4><p class='paragraph'></p>Displays the inner body content if the user is authenticated.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifLoggedIn&gt;
Welcome Back!
&lt;/sec:ifLoggedIn&gt;</pre></div><p class='paragraph'></p><h4>ifNotLoggedIn</h4><p class='paragraph'></p>Displays the inner body content if the user is not authenticated.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifNotLoggedIn&gt;
&lt;g:link controller='login' action='auth'&gt;Login&lt;/g:link&gt;
&lt;/sec:ifNotLoggedIn&gt;</pre></div><p class='paragraph'></p><h4>ifAllGranted</h4><p class='paragraph'></p>Displays the inner body content only if all of the listed roles are granted.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifAllGranted roles=<span class='java-quote'>"ROLE_ADMIN,ROLE_SUPERVISOR"</span>&gt;secure stuff here&lt;/sec:ifAllGranted&gt;</pre></div><p class='paragraph'></p><h4>ifAnyGranted</h4><p class='paragraph'></p>Displays the inner body content if at least one of the listed roles are granted.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifAnyGranted roles=<span class='java-quote'>"ROLE_ADMIN,ROLE_SUPERVISOR"</span>&gt;secure stuff here&lt;/sec:ifAnyGranted&gt;</pre></div><p class='paragraph'></p><h4>ifNotGranted</h4><p class='paragraph'></p>Displays the inner body content if none of the listed roles are granted.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifNotGranted roles=<span class='java-quote'>"ROLE_USER"</span>&gt;non-user stuff here&lt;/sec:ifNotGranted&gt;</pre></div><p class='paragraph'></p><h4> loggedInUserInfo</h4><p class='paragraph'></p>Displays the value of the specified authentication field if logged in. For example this will show the username property:<p class='paragraph'></p><div class='code'><pre>&lt;sec:loggedInUserInfo field=<span class='java-quote'>"username"</span>/&gt;</pre></div><p class='paragraph'></p>and if you have customized the authentication to add a <code>fullName</code> property, you would access it using<p class='paragraph'></p><div class='code'><pre>Welcome Back &lt;sec:loggedInUserInfo field=<span class='java-quote'>"fullName"</span>/&gt;</pre></div><p class='paragraph'></p><h4> username</h4><p class='paragraph'></p>Displays the value of the authentication <code>username</code> field if logged in.<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifLoggedIn&gt;
Welcome Back &lt;sec:username/&gt;!
&lt;/sec:ifLoggedIn&gt;
&lt;sec:ifNotLoggedIn&gt;
&lt;g:link controller='login' action='auth'&gt;Login&lt;/g:link&gt;
&lt;/sec:ifNotLoggedIn&gt;</pre></div><p class='paragraph'></p><h4>ifSwitched</h4><p class='paragraph'></p>Displays the inner body content only if the current user switched from another user.<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifLoggedIn&gt;
Logged in as &lt;sec:username/&gt;
&lt;/sec:ifLoggedIn&gt;<p class='paragraph'></p>&lt;sec:ifSwitched&gt;
&lt;a href='${request.contextPath}/j_spring_security_exit_user'&gt;
   Resume as &lt;sec:switchedUserOriginalUsername/&gt;
&lt;/a&gt;
&lt;/sec:ifSwitched&gt;<p class='paragraph'></p>&lt;sec:ifNotSwitched&gt;<p class='paragraph'></p>   &lt;sec:ifAllGranted roles='ROLE_SWITCH_USER'&gt;<p class='paragraph'></p>   &lt;form action='${request.contextPath}/j_spring_security_switch_user' method='POST'&gt;<p class='paragraph'></p>      Switch to user: &lt;input type='text' name='j_username'/&gt;&lt;br/&gt;<p class='paragraph'></p>      &lt;input type='submit' value='Switch'/&gt; &lt;/form&gt;<p class='paragraph'></p>   &lt;/sec:ifAllGranted&gt;<p class='paragraph'></p>&lt;/sec:ifNotSwitched&gt;</pre></div><p class='paragraph'></p><h4>ifNotSwitched</h4><p class='paragraph'></p>Displays the inner body content only if the current user has not switched from another user.<p class='paragraph'></p><h4>switchedUserOriginalUsername</h4><p class='paragraph'></p>Renders the original user's username if the current user switched from another user.<p class='paragraph'></p><h2><a name='4.2. SpringSecurityService'>4.2. SpringSecurityService</a></h2><code>grails.plugins.springsecurity.SpringSecurityService</code> provides security utility functions. It's a regular Grails service, so you can use dependency injection to inject it into a controller, service, taglib, etc.:<p class='paragraph'></p><div class='code'><pre>def springSecurityService</pre></div><p class='paragraph'></p><h4>isLoggedIn()</h4><p class='paragraph'></p>Checks to see if there's a currently logged-in user.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class SomeController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def someAction = {
      <span class='java-keyword'>if</span> (springSecurityService.isLoggedIn()) {
         &#x2026;
      }
      <span class='java-keyword'>else</span> {
         &#x2026;
      }
   }
}</pre></div><p class='paragraph'></p><h4>getAuthentication()</h4><p class='paragraph'></p>Retrieves the current user's <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html'>Authentication</a> if logged in, or <code>null</code> otherwise.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class SomeController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def someAction = {
      def auth = springSecurityService.authentication
      <span class='java-object'>String</span> username = auth.username
      def authorities = auth.authorities // a Collection of GrantedAuthority
      <span class='java-object'>boolean</span> authenticated = auth.authenticated
      &#x2026;
   }
}</pre></div><p class='paragraph'></p><h4>getPrincipal()</h4><p class='paragraph'></p>Retrieves the currently logged in user's <code>Principal</code>, or <code>null</code> if not logged in. This will be a <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code> unless you've created a custom <code>UserDetailsService</code>, in which case it'll be whatever implementation of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetails.html'>UserDetails</a> you use there.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class SomeController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def someAction = {
      def principal = springSecurityService.principal
      <span class='java-object'>String</span> username = principal.username
      def authorities = principal.authorities // a Collection of GrantedAuthority
      <span class='java-object'>boolean</span> enabled = principal.enabled
      &#x2026;
   }
}</pre></div><p class='paragraph'></p><h4>encodePassword()</h4><p class='paragraph'></p>Encrypts a password using the configured encryption scheme. By default the plugin uses SHA-256, but this is configurable using the <code>grails.plugins.springsecurity.password.algorithm</code> attribute in <code>Config.groovy</code>. You can use any message digest algorithm that's supported in your JDK; see <a target='blank' href='http://java.sun.com/j2se/1.5.0/docs/guide/security/CryptoSpec.html#AppA'>this page</a> for information on what's available. In particular you are <strong class='bold'>strongly</strong> discouraged from using MD5 or SHA-1 algorithms since they are rather weak and have well-known vulnerabilities. You should also use a salt for your passwords, which greatly increases the computational complexity of decrypting passwords if your database gets compromised. See <a class='guide' href='../guide/single.html#10.5. Salted passwords'>here</a> for details on using salted passwords.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class PersonController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def updateAction = {
      def person = Person.get(params.id)<p class='paragraph'></p>      params.salt = person.salt
      <span class='java-keyword'>if</span> (person.password != params.password) {
         params.password = springSecurityService.encodePassword(password, salt)
         def salt = &#x2026; // e.g. randomly generated using some utility method
         params.salt = salt
      }
      person.properties = params
      <span class='java-keyword'>if</span> (!person.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'edit', model: [person: person]
         <span class='java-keyword'>return</span>
      }
      redirect action: show, id: person.id
   }
}</pre></div><p class='paragraph'></p><h4>updateRole()</h4><p class='paragraph'></p>Updates a role and if you're using <code>Requestmap</code> instances to manage securing URLs, will replace the new role name in all <code>Requestmap</code> definitions that use it if the name was changed.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class RoleController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def update = {
      def roleInstance = Role.get(params.id)
      <span class='java-keyword'>if</span> (!springSecurityService.updateRole(roleInstance, params)) {
         render view: 'edit', model: [roleInstance: roleInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The role was updated"</span>
      redirect action: show, id: roleInstance.id
   }
}</pre></div><p class='paragraph'></p><h4>deleteRole()</h4><p class='paragraph'></p>Deletes a role and if you're using <code>Requestmap</code> instances to manage securing URLs, will remove the role from all <code>Requestmap</code> definitions. If a <code>Requestmap</code>'s config attribute is just this role's name (e.g. "/foo/bar/<strong class='bold'></strong>=ROLE_FOO") it will be deleted.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class RoleController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def delete = {
      def roleInstance = Role.get(params.id)
      <span class='java-keyword'>try</span> {
         springSecurityService.deleteRole (roleInstance
         flash.message = <span class='java-quote'>"The role was deleted"</span>
         redirect action: list
      }
      <span class='java-keyword'>catch</span> (DataIntegrityViolationException e) {
         flash.message = <span class='java-quote'>"Unable to delete the role"</span>
         redirect action: show, id: params.id
      }
   }
}</pre></div><p class='paragraph'></p><h4>clearCachedRequestmaps()</h4><p class='paragraph'></p>If you're using <code>Requestmap</code> instances to manage securing URLs, the plugin will load and cache all <code>Requestmap</code> instances as a performance optimization. This saves a lot of database activity since the requestmaps are checked for each request. But you can't allow the cache to become stale, so when you create, edit or delete a <code>Requestmap</code> you should flush the cache to trigger a complete reload. Both <code>updateRole()</code> and <code>deleteRole()</code> call this method for you, so you should call this when you create a new <code>Requestmap</code> or if you do some other <code>Requestmap</code> work that would affect the cache.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class RequestmapController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def save = {
      def requestmapInstance = <span class='java-keyword'>new</span> Requestmap(params)
      <span class='java-keyword'>if</span> (!requestmapInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'create', model: [requestmapInstance: requestmapInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p>      springSecurityService.clearCachedRequestmaps()
      flash.message = <span class='java-quote'>"Requestmap created"</span>
      redirect action: show, id: requestmapInstance.id
   }
}</pre></div><p class='paragraph'></p><h4>reauthenticate()</h4><p class='paragraph'></p>Rebuilds an <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html'>Authentication</a> for the given username and registers it in the security context. This is typically used after updating a user's authorities or other data that is cached in the <code>Authentication</code> or <code>Principal</code>. It slso removes the user from the user cache to force a refresh at next login.<p class='paragraph'></p>Example:<p class='paragraph'></p><div class='code'><pre>class UserController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def update = {
      def userInstance = User.get(params.id)<p class='paragraph'></p>      params.salt = person.salt
      <span class='java-keyword'>if</span> (userInstance.password != params.password) {
         params.password = springSecurityService.encodePassword(params.password, salt)
         def salt = &#x2026; // e.g. randomly generated using some utility method
         params.salt = salt
      }
      userInstance.properties = params
      <span class='java-keyword'>if</span> (!userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'edit', model: [userInstance: userInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p><span class='java-keyword'>if</span> (springSecurityService.loggedIn &amp;&amp;
             springSecurityService.principal.username == userInstance.username) {
         springSecurityService.reauthenticate userInstance.username
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The user was updated"</span>
      redirect action: show, id: userInstance.id
   }
}</pre></div><p class='paragraph'></p><h2><a name='4.3. SpringSecurityUtils'>4.3. SpringSecurityUtils</a></h2><code>org.codehaus.groovy.grails.plugins.springsecurity.SpringSecurityUtils</code> is a utility class with static methods that can be called directly without using dependency injection. It's primarily an internal class but can be called from application code.<p class='paragraph'></p><h4>authoritiesToRoles()</h4><p class='paragraph'></p>Extracts role names from an array or <code>Collection</code> of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/GrantedAuthority.html'>GrantedAuthority</a>.<p class='paragraph'></p><h4>getPrincipalAuthorities()</h4><p class='paragraph'></p>Retrieves the currently logged-in user's authorities. Will be empty (but never <code>null</code>) if not logged in.<p class='paragraph'></p><h4>parseAuthoritiesString()</h4><p class='paragraph'></p>Splits a comma-delimited String containing role names into a <code>List</code> of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/GrantedAuthority.html'>GrantedAuthority</a><p class='paragraph'></p><h4>ifAllGranted()</h4><p class='paragraph'></p>Checks if the current user has all of the specified roles (a comma-delimited String of role names). This is primarily used by <code>SecurityTagLib.ifAllGranted</code><p class='paragraph'></p><h4>ifNotGranted()</h4><p class='paragraph'></p>Checks if the current user has none of the specified roles (a comma-delimited String of role names). This is primarily used by <code>SecurityTagLib.ifNotGranted</code><p class='paragraph'></p><h4>ifAnyGranted()</h4><p class='paragraph'></p>Checks if the current user has any of the specified roles (a comma-delimited String of role names). This is primarily used by <code>SecurityTagLib.ifAnyGranted</code><p class='paragraph'></p><h4>getSecurityConfig()</h4><p class='paragraph'></p>Retrieves the security part of the <code>Configuration</code> (from <code>grails-app/conf/Config.groovy</code>).<p class='paragraph'></p><h4>loadSecondaryConfig()</h4><p class='paragraph'></p>Used by dependent plugins to add configuration attributes.<p class='paragraph'></p><h4>reloadSecurityConfig()</h4><p class='paragraph'></p>Forces a reload of the security configuration.<p class='paragraph'></p><h4>isAjax()</h4><p class='paragraph'></p>Checks if the request was triggered by an Ajax call. The standard way to determine this is to see if <code>X-Requested-With</code> request header is set and has the value <code>XMLHttpRequest</code>. The plugin relaxes this a bit and only checks if the header is set to any value. In addition, you can configure the name of the header using the <code>grails.plugins.springsecurity.ajaxHeader</code> configuration attribute, but this shouldn't be done in general since all of the major JavaScript toolkits use the standard name.<p class='paragraph'></p>In addition, you can force the request to be treated as Ajax by appending <code>&amp;ajax=true</code> to your request query string.<p class='paragraph'></p><h4>registerProvider()</h4><p class='paragraph'></p>Used by dependent plugins to register an <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AuthenticationProvider.html'>AuthenticationProvider</a> bean name.<p class='paragraph'></p><h4>registerFilter()</h4><p class='paragraph'></p>Used by dependent plugins to register a filter bean name in a specified position in the filter chain.<p class='paragraph'></p><h4>isSwitched()</h4><p class='paragraph'></p>Checks if the current user switched from another user.<p class='paragraph'></p><h4>getSwitchedUserOriginalUsername()</h4><p class='paragraph'></p>Gets the original user's username if the current user switched from another user.<p class='paragraph'></p><h1><a name='5. Events'>5. Events</a></h1>Spring Security fires application events after various security-related actions such as successful login, unsuccessful login, etc. There are two hierarchies of events, <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/event/AbstractAuthenticationEvent.html'>AbstractAuthenticationEvent</a> and <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/event/AbstractAuthorizationEvent.html'>AbstractAuthorizationEvent</a>.<p class='paragraph'></p>There are two main ways of being notified of these events when using the plugin:
<ul class='star'><li>register an event listener, ignoring events that you're not interested in (Spring only allows partial event subscription; you use generics to register the class of events you want to be notified of and it notifies you of those and all subclasses)</li><li>register one or more callback closures in <code>grails-app/conf/Config.groovy</code> that take advantage of the plugin's <code>org.codehaus.groovy.grails.plugins.springsecurity.SecurityEventListener</code> which does the filtering for you</li></ul><p class='paragraph'></p>The first approach involves creating one or more Groovy or Java classes, e.g.<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.foo.bar<p class='paragraph'></p><span class='java-keyword'>import</span> org.springframework.context.ApplicationListener
<span class='java-keyword'>import</span> org.springframework.security.authentication.event.AuthenticationSuccessEvent<p class='paragraph'></p>class MySecurityEventListener <span class='java-keyword'>implements</span> ApplicationListener&lt;AuthenticationSuccessEvent&gt; {<p class='paragraph'></p>   void onApplicationEvent(AuthenticationSuccessEvent event) {
      // handle the event
   }
}</pre></div><p class='paragraph'></p>registering them in <code>grails-app/conf/spring/resources.groovy</code>:<p class='paragraph'></p><div class='code'><pre>beans = {
   mySecurityEventListener(com.foo.bar.MySecurityEventListener)
}</pre></div><p class='paragraph'></p>Alternatively, you can just register one or more callback closure(s) in <code>grails-app/conf/Config.groovy</code> and let <code>SecurityEventListener</code> do all of the work for you, and you can just handle any event you like, e.g.:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useSecurityEventListener = <span class='java-keyword'>true</span><p class='paragraph'></p>grails.plugins.springsecurity.onInteractiveAuthenticationSuccessEvent = { e, appCtx -&gt;
   // handle InteractiveAuthenticationSuccessEvent
}<p class='paragraph'></p>grails.plugins.springsecurity.onAbstractAuthenticationFailureEvent = { e, appCtx -&gt;
   // handle AbstractAuthenticationFailureEvent
}<p class='paragraph'></p>grails.plugins.springsecurity.onAuthenticationSuccessEvent = { e, appCtx -&gt;
   // handle AuthenticationSuccessEvent
}<p class='paragraph'></p>grails.plugins.springsecurity.onAuthenticationSwitchUserEvent = { e, appCtx -&gt;
   // handle AuthenticationSwitchUserEvent
}<p class='paragraph'></p>grails.plugins.springsecurity.onAuthorizationEvent = { e, appCtx -&gt;
   // handle AuthorizationEvent
}</pre></div><p class='paragraph'></p>None of these closures are required; if none are configured, nothing will be called. Just implement the event handlers that you need.<p class='paragraph'></p>Note that when a user authenticates, Spring Security initially fires an <code>AuthenticationSuccessEvent</code> but this happens before the <code>Authentication</code> is registered in the <code>SecurityContextHolder</code>. This means that the <code>springSecurityService</code> methods that access the logged-in user won't work. Later in the processing a second event is fired, an <code>InteractiveAuthenticationSuccessEvent</code>, and when this happens the <code>SecurityContextHolder</code> will have the <code>Authentication</code>. So depending on your needs you can choose to implement a callback for either or both events.<p class='paragraph'></p>Also note that your event callback(s) will be ignored unless you set the <code>useSecurityEventListener</code> property to true. This allows you to temporarily disable/enable them or enable them per-environment.<p class='paragraph'></p><h1><a name='6. Configuration'>6. Configuration</a></h1>Much of the Spring Security configuration is user-configurable. The configuration has sensible default values, but each application has special needs. Default values are in the plugin's <code>grails-app/conf/DefaultSecurityConfig.groovy</code> file and you can put application-specific values are in <code>grails-app/conf/Config.groovy</code>. The two configurations will be merged with application values overriding the defaults.<p class='paragraph'></p><blockquote class='note'>
All of these property overrides must be specified in <code>Config.groovy</code> using the <code>grails.plugins.springsecurity</code> suffix, for example
<div class='code'><pre>grails.plugins.springsecurity.userLookup.userDomainClassName =
     'com.mycompany.myapp.User'</pre></div></blockquote><p class='paragraph'></p><h4>Properties that are most likely to be overridden are the <code>User</code> and <code>Role</code> (and <code>Requestmap</code> if using the database to store mappings) class and field names:</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>userLookup.userDomainClassName</td><td>'Person'</td><td>User class name</td></tr><tr class='table-even'><td>userLookup.usernamePropertyName</td><td>'username'</td><td>User class username field</td></tr><tr class='table-odd'><td>userLookup.passwordPropertyName</td><td>'password'</td><td>User class password field</td></tr><tr class='table-even'><td>userLookup.authoritiesPropertyName</td><td>'authorities'</td><td>User class role collection field</td></tr><tr class='table-odd'><td>userLookup.enabledPropertyName</td><td>'enabled'</td><td>User class enabled field</td></tr><tr class='table-even'><td>userLookup.accountExpiredPropertyName</td><td>'accountExpired'</td><td>User class account expired field</td></tr><tr class='table-odd'><td>userLookup.accountLockedPropertyName</td><td>'accountLocked'</td><td>User class account locked field</td></tr><tr class='table-even'><td>userLookup.passwordExpiredPropertyName</td><td>'passwordExpired'</td><td>User class password expired field</td></tr><tr class='table-odd'><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr><tr class='table-even'><td>authority.className</td><td>'Authority'</td><td>Role class name</td></tr><tr class='table-odd'><td>authority.nameField</td><td>'authority'</td><td>Role class role name field</td></tr><tr class='table-even'><td>requestMap.className</td><td>'Requestmap'</td><td>Requestmap class name</td></tr><tr class='table-odd'><td>requestMap.urlField</td><td>'url'</td><td>Requestmap class URL pattern field</td></tr><tr class='table-even'><td>requestMap.configAttributeField</td><td>'configAttribute'</td><td>Requestmap class role/token field</td></tr></table><p class='paragraph'></p><h4>To customize the login error messages that are displayed for the various error conditions:</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>errors.login.fail</td><td>"Sorry, we were not able to find a user with that username and password."</td><td>message displayed when authentication is successful because of missing user or bad password</td></tr><tr class='table-even'><td>errors.login.disabled</td><td>"Sorry, your account is disabled."</td><td>message displayed when authentication is successful but user is not enabled</td></tr></table><p class='paragraph'></p><h4>rememberMeServices bean (cookie management)</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>rememberMe.cookieName</td><td>'grails_remember_me'</td><td>remember-me cookie name - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.alwaysRemember</td><td><code>false</code></td><td>create a remember-me cookie even if there's no checkbox on the form if <code>true</code></td></tr><tr class='table-odd'><td>rememberMe.tokenValiditySeconds</td><td>1209600 (14 days)</td><td>max age of the cookie in seconds</td></tr><tr class='table-even'><td>rememberMe.parameter</td><td>'_spring_security_remember_me'</td><td>Login form remember-me checkbox name</td></tr><tr class='table-odd'><td>rememberMe.key</td><td>'grailsRocks'</td><td>a value used to encode cookies - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.persistent</td><td><code>false</code></td><td>if <code>true</code> store persistent login information in the database</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.domainClassName</td><td>'PersistentLogin'</td><td>domain class used to manage persistent logins</td></tr><tr class='table-even'><td>rememberMe.persistentToken.seriesLength</td><td>16</td><td>the number of characters in the cookie's <code>series</code> attribute</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.tokenLength</td><td>16</td><td>the number of characters in the cookie's <code>token</code> attribute</td></tr><tr class='table-even'><td>atr.rememberMeClass</td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/RememberMeAuthenticationToken.html'>RememberMeAuthenticationToken</a></td><td>remember-me authentication class</td></tr></table><p class='paragraph'></p><h4>URL attributes</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>apf.filterProcessesUrl</td><td>'/j_spring_security_check'</td><td>login form post URL, intercepted by Spring Security filter</td></tr><tr class='table-even'><td>apf.usernameParameter</td><td>'j_username'</td><td>login form username parameter</td></tr><tr class='table-odd'><td>apf.passwordParameter</td><td>'j_password'</td><td>login form password parameter</td></tr><tr class='table-even'><td>apf.allowSessionCreation</td><td><code>true</code></td><td>whether or not to allow authentication to create an HTTP session</td></tr><tr class='table-odd'><td>apf.postOnly</td><td><code>true</code></td><td>whether to only allow POST login requests</td></tr><tr class='table-even'><td>failureHandler.defaultFailureUrl</td><td>'/login/authfail?login_error=1'</td><td>redirect URL for failed logins</td></tr><tr class='table-odd'><td>failureHandler.ajaxAuthFailUrl</td><td>'/login/authfail?ajax=true'</td><td>redirect URL for failed Ajax logins</td></tr><tr class='table-even'><td>failureHandler.exceptionMappings</td><td>none</td><td>a map of exception class name (subclass of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/AuthenticationException.html'>AuthenticationException</a>) to URL to redirect to for that exception type after authentication failure</td></tr><tr class='table-odd'><td>failureHandler.useForward</td><td><code>false</code></td><td>whether to render the error page (<code>true</code>) or redirect (<code>false</code>)</td></tr><tr class='table-even'><td>successHandler.defaultTargetUrl</td><td>'/'</td><td>default post-login URL if there's no saved request that triggered the login</td></tr><tr class='table-odd'><td>successHandler.alwaysUseDefault</td><td><code>false</code></td><td>if <code>true</code>, always redirect to the value of <code>successHandler.defaultTargetUrl</code> after successful authentication, otherwise redirects to to originally-requested page</td></tr><tr class='table-even'><td>successHandler.targetUrlParameter</td><td>'spring-security-redirect'</td><td>name of optional login form parameter that specifies destination after successful login</td></tr><tr class='table-odd'><td>successHandler.useReferer</td><td><code>false</code></td><td>whether to use the HTTP <code>Referer</code> header to determine post-login destination</td></tr><tr class='table-even'><td>successHandler.ajaxSuccessUrl</td><td>'/login/ajaxSuccess'</td><td>URL to redirect to after successful Ajax login</td></tr><tr class='table-odd'><td>auth.loginFormUrl</td><td>'/login/auth'</td><td>URL of login page</td></tr><tr class='table-even'><td>auth.forceHttps</td><td><code>false</code></td><td>if <code>true</code>, will redirect login page requests to HTTPS</td></tr><tr class='table-odd'><td>auth.ajaxLoginFormUrl</td><td>'/login/authAjax'</td><td>URL of Ajax login page</td></tr><tr class='table-even'><td>auth.useForward</td><td>false</td><td>whether to render the login page (<code>true</code>) or redirect (<code>false</code>)</td></tr><tr class='table-odd'><td>logout.afterLogoutUrl</td><td>'/'</td><td>URL to redirect to after logout</td></tr><tr class='table-even'><td>logout.filterProcessesUrl</td><td>'/j_spring_security_logout'</td><td>logout URL, intercepted by Spring Security filter</td></tr><tr class='table-odd'><td>logout.handlerNames</td><td>'rememberMeServices', 'securityContextLogoutHandler'</td><td>logout handler bean names; more details are <a class='guide' href='../guide/single.html#10.9. Logout Handlers'>here</a></td></tr><tr class='table-even'><td>adh.errorPage</td><td>'/login/denied'</td><td>location of the 403 error page</td></tr><tr class='table-odd'><td>adh.ajaxErrorPage</td><td>'/login/ajaxDenied'</td><td>location of the 403 error page for Ajax requests</td></tr><tr class='table-even'><td>ajaxHeader</td><td>'X-Requested-With'</td><td>header name sent by Ajax library, used to detect Ajax</td></tr><tr class='table-odd'><td>redirectStrategy.contextRelative</td><td><code>false</code></td><td>if <code>true</code>, the redirect URL will be the value after the request context path;  this will result in the loss of protocol information (HTTP or HTTPS), so will cause problems if a redirect is being performed to change from HTTP to HTTPS or vice versa</td></tr></table><p class='paragraph'></p><h4>Channel security (declaring which URLs must use HTTPS or HTTP)</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.7. Channel security'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>portMapper.httpPort</td><td>8080</td><td>the HTTP port your app uses</td></tr><tr class='table-even'><td>portMapper.httpsPort</td><td>8443</td><td>the HTTPS port your app uses</td></tr><tr class='table-odd'><td>secureChannel.definition</td><td>none</td><td>Map of URL pattern to channel rule</td></tr></table><p class='paragraph'></p><h4>IP address restrictions</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.8. IP Address Restrictions'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>ipRestrictions</td><td>none</td><td>a Map of URL patterns to IP address patterns</td></tr></table><p class='paragraph'></p><h4>Password encryption attributes</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default</strong></th><th><strong class='bold'>Description</strong></th></tr><tr class='table-odd'><td>password.algorithm</td><td>'SHA-256'</td><td>passwordEncoder Message Digest algorithm, see <a target='blank' href='http://java.sun.com/j2se/1.5.0/docs/guide/security/CryptoSpec.html#AppA'>this page</a> for options</td></tr><tr class='table-even'><td>password.encodeHashAsBase64</td><td><code>false</code></td><td>if <code>true</code>, Base64-encode the hashed password</td></tr></table><p class='paragraph'></p><h4>HTTP Basic Authentication</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.2. Basic and Digest Auth'>here</a><p class='paragraph'></p><h4>Digest Authentication</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.2. Basic and Digest Auth'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default</strong></th><th><strong class='bold'>Description</strong></th></tr><tr class='table-odd'><td>useBasicAuth</td><td><code>false</code></td><td>whether to use basic auth</td></tr><tr class='table-even'><td>basic.realmName</td><td>'Grails Realm'</td><td>the realm name displayed in the browser authentication popup</td></tr></table><p class='paragraph'></p><h4>Switch User</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.3. Switch User'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>useSwitchUserFilter</td><td><code>false</code></td><td>whether to use the switch user filter</td></tr><tr class='table-even'><td>switchUser.switchUserUrl</td><td>'/j_spring_security_switch_user'</td><td>url to access (via GET or POST) to switch to another user</td></tr><tr class='table-odd'><td>switchUser.exitUserUrl</td><td>'/j_spring_security_exit_user'</td><td>url to access to switch to another user</td></tr><tr class='table-even'><td>switchUser.targetUrl</td><td>the same as <code>successHandler.defaultTargetUrl</code></td><td>the URL to redirect to after switching</td></tr><tr class='table-odd'><td>switchUser.switchFailureUrl</td><td>the same as <code>failureHandler.defaultFailureUrl</code></td><td>the URL to redirect to after an error attempting to switch</td></tr></table><p class='paragraph'></p><h4>Session Fixation</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.4. Session Fixation'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th>&#xa0;</th></tr><tr class='table-odd'><td>useSessionFixation</td><td><code>false</code></td><td>whether to use session fixation</td></tr><tr class='table-even'><td>sessionFixation.migrate</td><td><code>true</code></td><td>whether to copy the session attributes of the existing session to the new session after login</td></tr><tr class='table-odd'><td>sessionFixation.alwaysCreateSession</td><td><code>false</code></td><td>whether to always create a session even if one didn't exist at the start of the request</td></tr></table><p class='paragraph'></p><h4>Certificate (X509) login</h4><p class='paragraph'></p>More configuration details are <a class='guide' href='../guide/single.html#10.6. Certificate (X509) login'>here</a><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>useX509</td><td><code>false</code></td><td>whether to support certificate-based logins</td></tr><tr class='table-even'><td>x509.continueFilterChainOnUnsuccessfulAuthentication</td><td><code>true</code></td><td>whether to proceed when an authentication attempt fails to allow other authentication mechanisms to process the request</td></tr><tr class='table-odd'><td>x509.subjectDnRegex</td><td>'CN=(.*?),'</td><td>the regex for extracting the username from the certificate's subject name</td></tr><tr class='table-even'><td>x509.checkForPrincipalChanges</td><td><code>false</code></td><td>whether to re-extract the username from the certificate and check that it's still the current user when there's a valid <code>Authentication</code> already</td></tr><tr class='table-odd'><td>x509.invalidateSessionOnPrincipalChange</td><td><code>true</code></td><td>whether to invalidate the session if the principal changed (based on a <code>checkForPrincipalChanges</code> check)</td></tr></table><p class='paragraph'></p><h4>Other miscellaneous attributes</h4><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>active</td><td><code>true</code></td><td>whether the plugin is enabled</td></tr><tr class='table-even'><td>rejectIfNoRule</td><td><code>false</code></td><td>'strict' mode where an explicit grant is required to access any resource; if <code>true</code> make sure to allow <code>IS_AUTHENTICATED_ANONYMOUSLY</code> for '/', '/js/**', '/css/**', '/images/**', '/login/**', '/logout/**', etc.</td></tr><tr class='table-odd'><td>anon.key</td><td>'foo'</td><td>anonymousProcessingFilter key</td></tr><tr class='table-even'><td>anon.userAttribute</td><td>'anonymousUser, ROLE_ANONYMOUS'</td><td>anonymousProcessingFilter username and role</td></tr><tr class='table-odd'><td>atr.anonymousClass</td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AnonymousAuthenticationToken.html'>AnonymousAuthenticationToken</a></td><td>anonymous token class</td></tr><tr class='table-even'><td>useHttpSessionEventPublisher</td><td><code>false</code></td><td>if <code>true</code>, an <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/session/HttpSessionEventPublisher.html'>HttpSessionEventPublisher</a> will be configured</td></tr><tr class='table-odd'><td>cacheUsers</td><td><code>false</code></td><td>if <code>true</code>, logins are cached using an <code>EhCache</code></td></tr><tr class='table-even'><td>useSecurityEventListener</td><td><code>false</code></td><td>if <code>true</code>, configure <code>SecurityEventListener</code>; more details <a class='guide' href='../guide/single.html#5. Events'>here</a></td></tr><tr class='table-odd'><td>dao.reflectionSaltSourceProperty</td><td>none</td><td>which property to use for the reflection-based salt source; more details <a class='guide' href='../guide/single.html#10.5. Salted passwords'>here</a></td></tr><tr class='table-even'><td>requestCache.onlyOnGet</td><td><code>false</code></td><td>whether to only cache a <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/savedrequest/SavedRequest.html'>SavedRequest</a> on GET requests</td></tr><tr class='table-odd'><td>requestCache.createSession</td><td><code>true</code></td><td>whether caching <code>SavedRequest</code> can trigger the creation of a session</td></tr><tr class='table-even'><td>authenticationDetails.authClass</td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/WebAuthenticationDetails.html'>WebAuthenticationDetails</a></td><td>the <code>Authentication</code> details class to use</td></tr><tr class='table-odd'><td>roleHierarchy</td><td>none</td><td>hierarchical role definition; more details <a class='guide' href='../guide/single.html#10.12. Hierarchical Roles'>here</a></td></tr><tr class='table-even'><td>voterNames</td><td>'authenticatedVoter', 'roleVoter'</td><td>bean names of voters; more details <a class='guide' href='../guide/single.html#10.10. Voters'>here</a></td></tr><tr class='table-odd'><td>providerNames</td><td>'daoAuthenticationProvider', 'anonymousAuthenticationProvider', 'rememberMeAuthenticationProvider'</td><td>bean names of authentication providers; more details <a class='guide' href='../guide/single.html#10.11. Authentication Providers'>here</a></td></tr><tr class='table-even'><td>securityConfigType</td><td>type of request mapping to use</td><td>one of <code>SecurityConfigType.Annotation</code>, <code>SecurityConfigType.Requestmap</code>, or <code>SecurityConfigType.InterceptUrlMap</code>; more details <a class='guide' href='../guide/single.html#3. Securing URLs'>here</a></td></tr><tr class='table-odd'><td>controllerAnnotations.matcher</td><td>'ant'</td><td>whether to use an Ant-style URL matcher ('ant') or Regex ('regex')</td></tr><tr class='table-even'><td>controllerAnnotations.lowercase</td><td><code>true</code></td><td>whether to do URL comparisons using lowercase</td></tr><tr class='table-odd'><td>controllerAnnotations.staticRules</td><td>none</td><td>extra rules that cannot be mapped using annotations</td></tr><tr class='table-even'><td>interceptUrlMap</td><td>none</td><td>request mapping definition when using <code>SecurityConfigType.InterceptUrlMap</code>; more details <a class='guide' href='../guide/single.html#3.2 Config.groovy'>here</a></td></tr><tr class='table-odd'><td>registerLoggerListener</td><td><code>false</code></td><td>if <code>true</code> registers a <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/event/LoggerListener.html'>LoggerListener</a> which logs interceptor-related application events</td></tr></table><p class='paragraph'></p><h1><a name='7. Custom UserDetailsService'>7. Custom UserDetailsService</a></h1>Hopefully the default configuraton plus the configurability exposed in <code>DefaultSecurityConfig.groovy</code> and <code>grails-app/conf/Config.groovy</code> enable most customization needs for your applications. However security is a large topic and there are many possible ways to secure an application.<p class='paragraph'></p>When authenticating users from a database using <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/dao/DaoAuthenticationProvider.html'>DaoAuthenticationProvider</a> (the default mode in the plugin if you haven't enabled OpenID, LDAP, etc.), an implementation of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetailsService.html'>UserDetailsService</a> is required. This class is responsible for returning a concrete implementation of <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetails.html'>UserDetails</a>. The plugin provides <code>org.codehaus.groovy.grails.plugins.springsecurity.GormUserDetailsService</code> as its <code>UserDetailsService</code> implementation and <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code> (which extends Spring Security's <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html'>User</a>) as its <code>UserDetails</code> implementation.<p class='paragraph'></p>You can extend or replace <code>GormUserDetailsService</code> with your own implementation by defining a bean in <code>grails-app/conf/spring/resources.groovy</code> (or <code>resources.xml</code>) with the same bean name, <code>userDetailsService</code>. This works because application beans are configured after plugin beans and there can only be one bean for each name.<p class='paragraph'></p>Here's an example <code>UserDetails</code> and <code>UserDetailsService</code> implementation that adds the full name of the user domain class in addition to the standard information. If you extract extra data from your domain class, you'll be less likely to need to reload the user from the database - most of your common data can be kept along with your security credentials.<p class='paragraph'></p>In this example we're adding in a <code>fullName</code> field. Keeping the full name cached avoids hitting the database just for that lookup. <code>GrailsUser</code> already adds the <code>id</code> value from the domain class to so we can do a more efficient database load of the user. If all you have is the username, then you need to call <code>User.findByUsername(principal.username)</code>, but if you have the id you can call <code>User.get(principal.id)</code>. Even if you have a unique index on the <code>username</code> database column, loading by primary key will usually be more efficient since it can take advantage of Hibernate's first-level and second-level caches.<p class='paragraph'></p>There's really not much to implement other than your application-specific lookup code:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.foo.bar<p class='paragraph'></p><span class='java-keyword'>import</span> org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser<p class='paragraph'></p><span class='java-keyword'>import</span> org.springframework.security.core.GrantedAuthority
<span class='java-keyword'>import</span> org.springframework.security.core.userdetails.User<p class='paragraph'></p>class MyUserDetails <span class='java-keyword'>extends</span> GrailsUser {<p class='paragraph'></p><span class='java-keyword'>final</span><span class='java-object'>String</span> fullName<p class='paragraph'></p>   MyUserDetails(<span class='java-object'>String</span> username, <span class='java-object'>String</span> password, <span class='java-object'>boolean</span> enabled,
                 <span class='java-object'>boolean</span> accountNonExpired, <span class='java-object'>boolean</span> credentialsNonExpired,
                 <span class='java-object'>boolean</span> accountNonLocked,
                 Collection&lt;GrantedAuthority&gt; authorities,
                 <span class='java-object'>long</span> id, <span class='java-object'>String</span> fullName) {
      <span class='java-keyword'>super</span>(username, password, enabled, accountNonExpired,
            credentialsNonExpired, accountNonLocked, authorities, id)<p class='paragraph'></p><span class='java-keyword'>this</span>.fullName = fullName
   }
}</pre></div><p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.foo.bar<p class='paragraph'></p><span class='java-keyword'>import</span> org.springframework.security.core.userdetails.UserDetails
<span class='java-keyword'>import</span> org.springframework.security.core.userdetails.UserDetailsService<p class='paragraph'></p>class MyUserDetailsService <span class='java-keyword'>implements</span> UserDetailsService {<p class='paragraph'></p>   UserDetails loadUserByUsername(<span class='java-object'>String</span> username) <span class='java-keyword'>throws</span> UsernameNotFoundException {
      // lookup user and data
      <span class='java-keyword'>return</span><span class='java-keyword'>new</span> MyUserDetails(username, password, enabled,
                               accountNonExpired, credentialsNonExpired,
                               accountNonLocked, authorities, id, fullName)
   }
}</pre></div><p class='paragraph'></p>and to use it, register it in <code>grails-app/conf/spring/resources.groovy</code> like this:<p class='paragraph'></p><div class='code'><pre>beans = {
   userDetailsService(com.foo.bar.MyUserDetailsService)
}</pre></div><p class='paragraph'></p>Another option if you want to load users and roles from the database is to subclass <code>org.codehaus.groovy.grails.plugins.springsecurity.GormUserDetailsService</code> - the methods are all protected so you can override whatever you want.<p class='paragraph'></p>Also note that this approach works with all beans defined in <code>SpringSecurityCoreGrailsPlugin.doWithSpring()</code> - you can replace or subclass any of the Spring beans to provide your own functionality when the standard extension mechanisms aren't sufficient.<p class='paragraph'></p><h4>Flushing the cached <code>Authentication</code></h4><p class='paragraph'></p>If you store mutable data in your custom <code>UserDetails</code> implementation (for example full name like in this example), be sure to rebuild the <code>Authentication</code> if it changes. <code>springSecurityService</code> has a <code>reauthenticate</code> method that will do this for you:<p class='paragraph'></p><div class='code'><pre>class MyController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def someAction {
      def user = &#x2026;
      // update user data
      user.save()
      springSecurityService.reauthenticate user.username
      &#x2026;
   }
}</pre></div><p class='paragraph'></p><h1><a name='8. Ajax Authentication'>8. Ajax Authentication</a></h1>The typical pattern of using web site authentication to access restricted pages involves intercepting access requests for secure pages, redirecting to a login page (possibly off-site) and redirecting back to the originally-requested page after a successful login. Each page can also have a login link to allow explicit logins at any time.<p class='paragraph'></p>Another option is to also have a login link on each page and use Ajax and DHTML to present a login form within the current page in a popup. The form submits the authentication request via Ajax and displays success or error messages as appropriate.<p class='paragraph'></p>The plugin has support for Ajax logins but you'll need to create your own GSP code. There are only a few necessary changes, and of course the sample code here is pretty basic so you should enhance it for your needs.<p class='paragraph'></p>The approach I'll show here involves editing your template page(s) to show "You're logged in as ..." text if logged in and a login link if not, along with a hidden login form that's shown using DHTML.<p class='paragraph'></p>Here's the updated <code>grails-app/views/layouts/main.gsp</code>:<p class='paragraph'></p><div class='code'><pre>&lt;html&gt;<p class='paragraph'></p>&lt;head&gt;
&lt;title&gt;&lt;g:layoutTitle <span class='java-keyword'>default</span>=<span class='java-quote'>"Grails"</span> /&gt;&lt;/title&gt;
&lt;link rel=<span class='java-quote'>"stylesheet"</span> href=<span class='java-quote'>"${resource(dir:'css',file:'main.css')}"</span> /&gt;
&lt;link rel=<span class='java-quote'>"shortcut icon"</span> type=<span class='java-quote'>"image/x-icon"</span>
      href=<span class='java-quote'>"${resource(dir:'images',file:'favicon.ico')}"</span> /&gt;
&lt;g:layoutHead /&gt;
&lt;/head&gt;<p class='paragraph'></p>&lt;body&gt;<p class='paragraph'></p>   &lt;div id=<span class='java-quote'>"spinner"</span> class=<span class='java-quote'>"spinner"</span> style=<span class='java-quote'>"display:none;"</span>&gt;
      &lt;img src=<span class='java-quote'>"${resource(dir:'images',file:'spinner.gif')}"</span> alt=<span class='java-quote'>"Spinner"</span> /&gt;
   &lt;/div&gt;<p class='paragraph'></p>   &lt;div id=<span class='java-quote'>"grailsLogo"</span> class=<span class='java-quote'>"logo"</span>&gt;
      &lt;a href=<span class='java-quote'>"http://grails.org"</span>&gt;
         &lt;img src=<span class='java-quote'>"${resource(dir:'images',file:'grails_logo.png')}"</span> alt=<span class='java-quote'>"Grails"</span> border=<span class='java-quote'>"0"</span> /&gt;
      &lt;/a&gt;<p class='paragraph'></p>      &lt;span id='loginLink' style='position: relative; margin-right: 30px; <span class='java-object'>float</span>: right'&gt;
      &lt;sec:ifLoggedIn&gt;
         Logged in as &lt;sec:username/&gt; (&lt;g:link controller='logout'&gt;Logout&lt;/g:link&gt;)
      &lt;/sec:ifLoggedIn&gt;
      &lt;sec:ifNotLoggedIn&gt;
         &lt;a href='#' onclick='showLogin(); <span class='java-keyword'>return</span><span class='java-keyword'>false</span>;'&gt;Login&lt;/a&gt;
      &lt;/sec:ifNotLoggedIn&gt;
      &lt;/span&gt;<p class='paragraph'></p>   &lt;/div&gt;<p class='paragraph'></p>   &lt;g:javascript src='application.js' /&gt;
   &lt;g:javascript library='prototype' /&gt;
   &lt;g:javascript src='prototype/scriptaculous.js?load=effects' /&gt;<p class='paragraph'></p>   &lt;g:render template='/includes/ajaxLogin'/&gt;<p class='paragraph'></p>   &lt;g:layoutBody /&gt;<p class='paragraph'></p>   &lt;/body&gt;
&lt;/html&gt;</pre></div><p class='paragraph'></p>The changes to note here include:
<ul class='star'><li>the prototype and scriptaculous libraries are included for Ajax support and to hide and show the login form</li><li>there's an include of the template <code>/includes/ajaxLogin</code> (see the code below)</li><li>there's a &lt;span&gt; positioned in the top-right which shows the username and a logout link when logged in, and a login link otherwise</li></ul><p class='paragraph'></p>Here's the content of the login form template (<code>grails-app/views/includes/_ajaxLogin.gsp</code>) - note that the CSS and Javascript are shown inline, but should be extracted to their own static files:<p class='paragraph'></p><div class='code'><pre>&lt;style&gt;
#ajaxLogin {
   margin: 15px 0px; padding: 0px;
   text-align: center;
   display: none;
   position: absolute;
}
#ajaxLogin .<span class='java-keyword'>inner</span> {
   width: 260px;
   margin:0px auto;
   text-align:left;
   padding:10px;
   border-top:1px dashed #499ede;
   border-bottom:1px dashed #499ede;
   background-color:#EEF;
}
#ajaxLogin .<span class='java-keyword'>inner</span> .fheader {
   padding:4px;margin:3px 0px 3px 0;color:#2e3741;font-size:14px;font-weight:bold;
}
#ajaxLogin .<span class='java-keyword'>inner</span> .cssform p {
   clear: left;
   margin: 0;
   padding: 5px 0 8px 0;
   padding-left: 105px;
   border-top: 1px dashed gray;
   margin-bottom: 10px;
   height: 1%;
}
#ajaxLogin .<span class='java-keyword'>inner</span> .cssform input[type='text'] {
   width: 120px;
}
#ajaxLogin .<span class='java-keyword'>inner</span> .cssform label{
   font-weight: bold;
   <span class='java-object'>float</span>: left;
   margin-left: -105px;
   width: 100px;
}
#ajaxLogin .<span class='java-keyword'>inner</span> .login_message {color:red;}
#ajaxLogin .<span class='java-keyword'>inner</span> .text_ {width:120px;}
#ajaxLogin .<span class='java-keyword'>inner</span> .chk {height:12px;}
.errorMessage { color: red; }
&lt;/style&gt;<p class='paragraph'></p>&lt;div id='ajaxLogin'&gt;
   &lt;div class='<span class='java-keyword'>inner</span>'&gt;
   &lt;div class='fheader'&gt;Please Login..&lt;/div&gt;
   &lt;form action='${request.contextPath}/j_spring_security_check' method='POST'
       id='ajaxLoginForm' name='ajaxLoginForm' class='cssform'&gt;
      &lt;p&gt;
         &lt;label <span class='java-keyword'>for</span>='username'&gt;Login ID&lt;/label&gt;
         &lt;input type='text' class='text_' name='j_username' id='username' /&gt;
      &lt;/p&gt;
      &lt;p&gt;
         &lt;label <span class='java-keyword'>for</span>='password'&gt;Password&lt;/label&gt;
         &lt;input type='password' class='text_' name='j_password' id='password' /&gt;
      &lt;/p&gt;
      &lt;p&gt;
         &lt;label <span class='java-keyword'>for</span>='remember_me'&gt;Remember me&lt;/label&gt;
         &lt;input type='checkbox' class='chk' id='remember_me'
                name='_spring_security_remember_me'/&gt;
      &lt;/p&gt;
      &lt;p&gt;
         &lt;a href='javascript:void(0)' onclick='authAjax(); <span class='java-keyword'>return</span><span class='java-keyword'>false</span>;'&gt;Login&lt;/a&gt;
         &lt;a href='javascript:void(0)' onclick='cancelLogin(); <span class='java-keyword'>return</span><span class='java-keyword'>false</span>;'&gt;Cancel&lt;/a&gt;
      &lt;/p&gt;
   &lt;/form&gt;
    &lt;div style='display: none; text-align: left;' id='loginMessage'&gt;&lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;<p class='paragraph'></p>&lt;script type='text/javascript'&gt;<p class='paragraph'></p>// center the form
Event.observe(window, 'load', function() {
   <span class='java-keyword'>var</span> ajaxLogin = $('ajaxLogin');
   $('ajaxLogin').style.left = ((document.body.getDimensions().width -
                                 ajaxLogin.getDimensions().width) / 2) + 'px';
   $('ajaxLogin').style.top = ((document.body.getDimensions().height -
                                ajaxLogin.getDimensions().height) / 2) + 'px';
});<p class='paragraph'></p>function showLogin() {
   $('ajaxLogin').style.display = 'block';
}<p class='paragraph'></p>function cancelLogin() {
   Form.enable(document.ajaxLoginForm);
   Element.hide('ajaxLogin');
}<p class='paragraph'></p>function authAjax() {
   Form.enable(document.ajaxLoginForm);
   Element.update('loginMessage', 'Sending request ...');
   Element.show('loginMessage');<p class='paragraph'></p><span class='java-keyword'>var</span> form = document.ajaxLoginForm;
   <span class='java-keyword'>var</span> params = Form.serialize(form);
   Form.disable(form);
   <span class='java-keyword'>new</span> Ajax.Request(form.action, {
      method: 'POST',
      postBody: params,
      onSuccess: function(response) {
         Form.enable(document.ajaxLoginForm);
         <span class='java-keyword'>var</span> responseText = response.responseText || '[]';
         <span class='java-keyword'>var</span> json = responseText.evalJSON();
         <span class='java-keyword'>if</span> (json.success) {
            Element.hide('ajaxLogin');
            $('loginLink').update('Logged in as ' + json.username +
                                  ' (&lt;%=link(controller: 'logout') { 'Logout' }%&gt;)');
         }
         <span class='java-keyword'>else</span><span class='java-keyword'>if</span> (json.error) {
            Element.update('loginMessage', <span class='java-quote'>"&lt;span class='errorMessage'&gt;"</span> +
                                           json.error + '&lt;/error&gt;');
         }
         <span class='java-keyword'>else</span> {
            Element.update('loginMessage', responseText);
         }
      }
   });
}
&lt;/script&gt;</pre></div><p class='paragraph'></p>The important aspects of this code are:
<ul class='star'><li>the form posts to the same url as the regular form, <code>j_spring_security_check</code>; in fact the form is identical including the Remember Me checkbox, except that the submit button has been replaced with a hyperlink</li><li>error messages are displayed within the popup &lt;div&gt;</li><li>since there's no page redirect after successful login, the Javascript replaces the login link to give a visual indication that the user is logged in</li><li>details of logout are not shown, but this is achieved by redirecting the user to <code>/j_spring_security_logout</code></li></ul><p class='paragraph'></p><h4>So how does it work?</h4><p class='paragraph'></p>Most Ajax libraries (Prototype, JQuery, and Dojo as of v2.1) include an <code>X-Requested-With</code> header that indicates that the request was made by <code>XMLHttpRequest</code> instead of being triggered by clicking a regular hyperlink or form submit button. The plugin uses this header to detect Ajax login requests, and uses subclasses of some of Spring Security's classes to use different redirect urls for Ajax requests than regular requests. Instead of showing full pages, <code>LoginController</code> has JSON-generating methods <code>ajaxSuccess()</code>, <code>ajaxDenied()</code>, and <code>authfail()</code> that generate JSON that the login Javascript code can use to appropriately display success or error messages.<p class='paragraph'></p>You can see the Ajax-aware actions in <code>LoginController</code>, specifically <code>ajaxSuccess</code> and <code>ajaxDenied</code>, which send JSON responses that can be used by client JavaScript code. Also <code>authfail</code> will check whether the authentication request used Ajax and will render a JSON error response if it was.
<h1><a name='9. Tutorials'>9. Tutorials</a></h1><h2><a name='9.1. Using Controller annotations to secure URLs'>9.1. Using Controller annotations to secure URLs</a></h2><h4>Create your Grails application</h4><p class='paragraph'></p><pre class='bq'><code>
$ grails create-app bookstore
$ cd bookstore</code></pre><p class='paragraph'></p><h4>Install the plugin</h4><p class='paragraph'></p><pre class='bq'><code>
$ grails install-plugin spring-security-core</code></pre><p class='paragraph'></p><h4>Create the User and Role domain classes</h4><p class='paragraph'></p><pre class='bq'><code>
$ grails s2-quickstart com.testapp User Role</code></pre><p class='paragraph'></p>You can choose whatever names you like for your domain classes and the package they're in - these are just examples.<p class='paragraph'></p><blockquote class='note'>
Depending on your database, some names might not be valid. This goes for any domain classes you create, but names for security seem to have an affinity towards trouble. So before you use names like "User" or "Group", make sure they are not reserved keywords in your database.
</blockquote><p class='paragraph'></p>The script will create this User class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p>class User {<p class='paragraph'></p><span class='java-object'>String</span> username
   <span class='java-object'>String</span> password
   <span class='java-object'>boolean</span> enabled
   <span class='java-object'>boolean</span> accountExpired
   <span class='java-object'>boolean</span> accountLocked
   <span class='java-object'>boolean</span> passwordExpired<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      username blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
      password blank: <span class='java-keyword'>false</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      password column: '`password`'
   }<p class='paragraph'></p>   Set&lt;Role&gt; getAuthorities() {
      UserRole.findAllByUser(<span class='java-keyword'>this</span>).collect { it.role } as Set
   }
}</pre></div><p class='paragraph'></p>and this Role class:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p>class Role {<p class='paragraph'></p><span class='java-object'>String</span> authority<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      cache <span class='java-keyword'>true</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> constraints = {
      authority blank: <span class='java-keyword'>false</span>, unique: <span class='java-keyword'>true</span>
   }
}</pre></div><p class='paragraph'></p>and a domain class that maps the many-to-many join class, <code>UserRole</code>:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p><span class='java-keyword'>import</span> org.apache.commons.lang.builder.HashCodeBuilder<p class='paragraph'></p>class UserRole <span class='java-keyword'>implements</span> Serializable {<p class='paragraph'></p>   User user
   Role role<p class='paragraph'></p><span class='java-object'>boolean</span> equals(other) {
      <span class='java-keyword'>if</span> (!(other <span class='java-keyword'>instanceof</span> UserRole)) {
         <span class='java-keyword'>return</span><span class='java-keyword'>false</span>
      }<p class='paragraph'></p>      other.user?.id == user?.id &amp;&amp;
         other.role?.id == role?.id
   }<p class='paragraph'></p><span class='java-object'>int</span> hashCode() {
      def builder = <span class='java-keyword'>new</span> HashCodeBuilder()
      <span class='java-keyword'>if</span> (user) builder.append(user.id)
      <span class='java-keyword'>if</span> (role) builder.append(role.id)
      builder.toHashCode()
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole get(<span class='java-object'>long</span> userId, <span class='java-object'>long</span> roleId) {
      find 'from UserRole where user.id=:userId and role.id=:roleId',
         [userId: userId, roleId: roleId]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> UserRole create(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      <span class='java-keyword'>new</span> UserRole(user: user, role: role).save(flush: flush, insert: <span class='java-keyword'>true</span>)
   }<p class='paragraph'></p><span class='java-keyword'>static</span><span class='java-object'>boolean</span> remove(User user, Role role, <span class='java-object'>boolean</span> flush = <span class='java-keyword'>false</span>) {
      UserRole instance = UserRole.findByUserAndRole(user, role)
      instance ? instance.delete(flush: flush) : <span class='java-keyword'>false</span>
   }<p class='paragraph'></p><span class='java-keyword'>static</span> void removeAll(User user) {
      executeUpdate 'DELETE FROM UserRole WHERE user=:user', [user: user]
   }<p class='paragraph'></p><span class='java-keyword'>static</span> mapping = {
      id composite: ['role', 'user']
      version <span class='java-keyword'>false</span>
   }
}</pre></div><p class='paragraph'></p>It also creates some UI controllers and GSPs:
<ul class='star'><li><code>grails-app/controllers/LoginController.groovy</code></li><li><code>grails-app/controllers/LogoutController.groovy</code></li><li><code>grails-app/views/auth.gsp</code></li><li><code>grails-app/views/denied.gsp</code></li></ul><p class='paragraph'></p>Note that the script has edited <code>grails-app/conf/Config.groovy</code> and added the configuration for your domain classes. Make sure that the changes are correct.<p class='paragraph'></p><blockquote class='note'>
These generated files are not part of the plugin - these are your application files. So you're free to edit them however you like - they're examples to get you started. They only contain the minimum needed for the plugin, but you're free to add whatever extra fields and methods you like.
</blockquote><p class='paragraph'></p>The plugin has no support for CRUD actions and GSPs for your domain classes, the <code>spring-security-ui</code> plugin will supply a UI for those. So for now we'll create roles and users in <code>grails-app/conf/BootStrap.groovy</code><p class='paragraph'></p><h4>Create a controller that will be restricted by role</h4><p class='paragraph'></p><pre class='bq'><code>
$ grails create-controller com.testapp.Secure</code></pre><p class='paragraph'></p>This will create <code>grails-app/controllers/com/testapp/SecureController.groovy</code> - add some output so we can verify that things are working:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p>class SecureController {
   def index = {
      render 'Secure access only'
   }
}</pre></div><p class='paragraph'></p><h4>Start the server</h4><p class='paragraph'></p><pre class='bq'><code>
$ grails run-app</code></pre><p class='paragraph'></p>Before we secure the page, navigate to <a target='blank' href='http://localhost:8080/bookstore/secure'>http://localhost:8080/bookstore/secure</a> to verify that you can see the page without being logged in.<p class='paragraph'></p>Shut down the app (using CTRL-C) and edit <code>grails-app/conf/BootStrap.groovy</code> to add the security objects that we need:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> com.testapp.Role
<span class='java-keyword'>import</span> com.testapp.User
<span class='java-keyword'>import</span> com.testapp.UserRole<p class='paragraph'></p>class BootStrap {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def init = { servletContext -&gt;<p class='paragraph'></p>      def adminRole = <span class='java-keyword'>new</span> Role(authority: 'ROLE_ADMIN').save(flush: <span class='java-keyword'>true</span>)
      def userRole = <span class='java-keyword'>new</span> Role(authority: 'ROLE_USER').save(flush: <span class='java-keyword'>true</span>)<p class='paragraph'></p><span class='java-object'>String</span> password = springSecurityService.encodePassword('password')
      def testUser = <span class='java-keyword'>new</span> User(username: 'me', enabled: <span class='java-keyword'>true</span>, password: password)
      testUser.save(flush: <span class='java-keyword'>true</span>)<p class='paragraph'></p>      UserRole.create testUser, adminRole, <span class='java-keyword'>true</span><p class='paragraph'></p>      assert User.count() == 1
      assert Role.count() == 2
      assert UserRole.count() == 1
   }
}</pre></div><p class='paragraph'></p>Some things to note about what we did in <code>BootStrap.groovy</code>:
<ul class='star'><li>we use <code>springSecurityService</code> to encrypt the password</li><li>we're not using a traditional GORM many-to-many mapping for the User&lt;-&gt;Role relationship, instead we're mapping the join table with the <code>UserRole</code> class. This is a performance optimization that will help significantly if many users have one or more common roles</li><li>we're explicitly flushing the creates since <code>BootStrap</code> doesn't run in a transaction or OpenSessionInView</li></ul><p class='paragraph'></p>Edit <code>grails-app/controllers/SecureController.groovy</code> to import the annotation class and apply the annotation to restrict access:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SecureController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN'])
   def index = {
      render 'Secure access only'
   }
}</pre></div><p class='paragraph'></p>or<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.testapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>@Secured(['ROLE_ADMIN'])
class SecureController {
   def index = {
      render 'Secure access only'
   }
}</pre></div><p class='paragraph'></p>You can annotate the entire controller or individual actions. In this case since we only have one action we can do either.<p class='paragraph'></p>Now run <code>grails run-app</code> again and navigate to <a target='blank' href='http://localhost:8080/bookstore/secure'>http://localhost:8080/bookstore/secure</a> and this time, you should be presented with the login page. Log in with the username and password you used for the test user, and you should again be able to see the secure page.<p class='paragraph'></p>When logging in, you can test the Remember Me functionality. Check the checkbox, and once you've tested the secure page close your browser and re-open it. Navigate again the the secure page, and since you have a cookie stored, you shouldn't need to log in again. Logout at any time by navigating to <a target='blank' href='http://localhost:8080/bookstore/logout'>http://localhost:8080/bookstore/logout</a><p class='paragraph'></p><h4>Creating a UI</h4><p class='paragraph'></p>If you would like to have a CRUD UI to work with users and roles, there are a few things you need to do beyond running <code>grails generate-all</code>.<p class='paragraph'></p>The generated <code>UserController.save</code> action will look something like this:<p class='paragraph'></p><div class='code'><pre>def save = {
   def userInstance = <span class='java-keyword'>new</span> User(params)
   <span class='java-keyword'>if</span> (userInstance.save(flush: <span class='java-keyword'>true</span>)) {
      flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.created.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), userInstance.id])}"</span>
      redirect(action: <span class='java-quote'>"show"</span>, id: userInstance.id)
   }
   <span class='java-keyword'>else</span> {
      render(view: <span class='java-quote'>"create"</span>, model: [userInstance: userInstance])
   }
}</pre></div><p class='paragraph'></p>This will store cleartext passwords and you won't be able to authenticate, so add a call to encrypt the password with <code>springSecurityService</code>:<p class='paragraph'></p><div class='code'><pre>class UserController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   ...<p class='paragraph'></p>   def save = {
      def userInstance = <span class='java-keyword'>new</span> User(params)
      userInstance.password = springSecurityService.encodePassword(params.password)
      <span class='java-keyword'>if</span> (userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.created.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), userInstance.id])}"</span>
         redirect(action: <span class='java-quote'>"show"</span>, id: userInstance.id)
      }
      <span class='java-keyword'>else</span> {
         render(view: <span class='java-quote'>"create"</span>, model: [userInstance: userInstance])
      }
   }
}</pre></div><p class='paragraph'></p>Similarly when updating you'll need to encrypt the password if it changes. Change this:<p class='paragraph'></p><div class='code'><pre>def update = {
   def userInstance = User.get(params.id)
   <span class='java-keyword'>if</span> (userInstance) {
      <span class='java-keyword'>if</span> (params.version) {
         def version = params.version.toLong()
         &#x2026;
      }
      userInstance.properties = params
      <span class='java-keyword'>if</span> (!userInstance.hasErrors() &amp;&amp; userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.updated.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), userInstance.id])}"</span>
         redirect(action: <span class='java-quote'>"show"</span>, id: userInstance.id)
      }
      <span class='java-keyword'>else</span> {
         render(view: <span class='java-quote'>"edit"</span>, model: [userInstance: userInstance])
      }
   }
   <span class='java-keyword'>else</span> {
      flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.not.found.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), params.id])}"</span>
      redirect(action: <span class='java-quote'>"list"</span>)
   }
}</pre></div><p class='paragraph'></p>to<p class='paragraph'></p><div class='code'><pre>def update = {
   def userInstance = User.get(params.id)
   <span class='java-keyword'>if</span> (userInstance) {
      <span class='java-keyword'>if</span> (params.version) {
         def version = params.version.toLong()
         &#x2026;
      }
      <span class='java-keyword'>if</span> (userInstance.password != params.password) {
         params.password = springSecurityService.encodePassword(params.password)
      }
      userInstance.properties = params
      <span class='java-keyword'>if</span> (!userInstance.hasErrors() &amp;&amp; userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         <span class='java-keyword'>if</span> (springSecurityService.loggedIn &amp;&amp;
                springSecurityService.principal.username == userInstance.username) {
            springSecurityService.reauthenticate userInstance.username
         }
         flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.updated.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), userInstance.id])}"</span>
         redirect(action: <span class='java-quote'>"show"</span>, id: userInstance.id)
      }
      <span class='java-keyword'>else</span> {
         render(view: <span class='java-quote'>"edit"</span>, model: [userInstance: userInstance])
      }
   }
   <span class='java-keyword'>else</span> {
      flash.message = <span class='java-quote'>"${message(code: '<span class='java-keyword'>default</span>.not.found.message', args: [message(code: 'user.label', <span class='java-keyword'>default</span>: 'User'), params.id])}"</span>
      redirect(action: <span class='java-quote'>"list"</span>)
   }
}</pre></div><p class='paragraph'></p>Note that there's also a call to <code>springSecurityService.reauthenticate()</code> to ensure that the cached <code>Authentication</code> stays current.<p class='paragraph'></p><h1><a name='10. Extending and configuring the plugin'>10. Extending and configuring the plugin</a></h1><h2><a name='10.1. Filters'>10.1. Filters</a></h2>There are a few different approaches to configuring filter chain(s). The default way is to use configuration attributes to determine which extra filters to use (e.g. Basic Auth, Switch User, etc.) and add these to the 'core' filters. For example, setting <code>grails.plugins.springsecurity.useSwitchUserFilter = true</code> adds <code>switchUserProcessingFilter</code> to the filter chain (and in the correct order). The filter chain built here is applied to all URLs, so if you need more flexibility then you further refine it using <code>filterChain.chainMap</code> as discussed below.<p class='paragraph'></p><h4>filterNames</h4><p class='paragraph'></p>To define custom filters, remove a core filter from the chain (not recommended), or otherwise have control over the filter chain, you can specify the <code>filterNames</code> property as a list of strings, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.filterNames = [
   'httpSessionContextIntegrationFilter', 'logoutFilter', 'authenticationProcessingFilter',
   'myCustomProcessingFilter', 'rememberMeProcessingFilter', 'anonymousProcessingFilter',
   'exceptionTranslationFilter', 'filterInvocationInterceptor'
]</pre></div><p class='paragraph'></p>This will create a filter chain corresponding to the Spring beans with the specified names. As with the default approach, the filter chain built here is applied to all URLs.<p class='paragraph'></p><h4>chainMap</h4><p class='paragraph'></p>You can also define which filters to applied to different URL patterns using the <code>filterChain.chainMap</code> attribute. This involves defining a Map which specifies one or more lists of filter bean names, each with a corresponding URL pattern, e.g.:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.filterChain.chainMap = [
   '/urlpattern1/**': 'filter1,filter2,filter3,filter4',
   '/urlpattern2/**': 'filter1,filter3,filter5',
   '/**': 'JOINED_FILTERS',
]</pre></div><p class='paragraph'></p>In this example, four filters are applied to URLs matching <code>/urlpattern1/**</code> and three different filters are applied to URLs matching <code>/urlpattern2/**</code>. In addition the special token <code>JOINED_FILTERS</code> is applied to all URLs. This is a conventient way to specify that all defined filters (configured either with configuration rules like <code>useSwitchUserFilter</code> or explicitly using <code>filterNames</code>) should apply to this pattern.<p class='paragraph'></p>Note that the order of the mappings is important. Each URL will be tested in order from top to bottom to find the first matching one. So we need a <code>/**</code> catch-all rule at the end for URLs that aren't don't match one of the earlier rules.<p class='paragraph'></p><h4>clientRegisterFilter</h4><p class='paragraph'></p>An alternative to setting the <code>filterNames</code> property is <code>org.codehaus.groovy.grails.plugins.springsecurity.SpringSecurityUtils.clientRegisterFilter()</code>. This allows you to add a custom filter to the chain at a specified position. Each of the standard filters has a corresponding position in the chain (see <code>org.codehaus.groovy.grails.plugins.springsecurity.SecurityFilterPosition</code> for details). So if you have created an application-specific filter, register it in <code>grails-app/conf/spring/resources.groovy</code>:<p class='paragraph'></p><div class='code'><pre>beans = {
   myFilter(com.mycompany.myapp.MyFilter) {
      // properties
   }
}</pre></div><p class='paragraph'></p>and then register it in <code>grails-app/conf/BootStrap.groovy</code>:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> org.codehaus.groovy.grails.plugins.springsecurity.SecurityFilterPosition
<span class='java-keyword'>import</span> org.codehaus.groovy.grails.plugins.springsecurity.SpringSecurityUtils<p class='paragraph'></p>class BootStrap {<p class='paragraph'></p>   def init = { servletContext -&gt;
      SpringSecurityUtils.clientRegisterFilter(
          'myFilter', SecurityFilterPosition.OPENID_FILTER.order + 10)
   }
}</pre></div><p class='paragraph'></p>This bootstrap code will register your filter just after the Open ID filter (if it's configured). You cannot register a filter in the same position as another, so it's a good idea to add a small delta to its position to put it after or before a filter that it should be next to in the chain. Note that the Open ID filter position is just an example - add your filter in whatever position makes sense.
<h2><a name='10.2. Basic and Digest Auth'>10.2. Basic and Digest Auth</a></h2><h4>Basic Auth</h4>
To use <a target='blank' href='http://en.wikipedia.org/wiki/Basic_access_authentication'>HTTP Basic Authentication</a> in your application set the <code>useBasicAuth</code> attribute to <code>true</code>. You should also change the <code>basic.realmName</code> from its default value to one that's appropriate for your application, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useBasicAuth = <span class='java-keyword'>true</span>
grails.plugins.springsecurity.basic.realmName = <span class='java-quote'>"Ralph's Bait and Tackle"</span></pre></div><p class='paragraph'></p>With this in place, users will be prompted with the standard browser login dialog instead of being redirected to a login page.<p class='paragraph'></p><h4>Digest Auth</h4><p class='paragraph'></p><a target='blank' href='http://en.wikipedia.org/wiki/Digest_access_authentication'>Digest Authentication</a> is similar to Basic auth but is more secure in that it doesn't send your password in obfuscated cleartext. It looks just like Basic auth in practice - you get the same browser popup dialog when you authenticate. But since the credential transfer is genuinely encrypted (instead of just Base64-encoded as with Basic auth) you don't need to use SSL to guard your logins.<p class='paragraph'></p>There is one issue with using Digest auth - by default you must store cleartext passwords in your database. This is because the browser encrypts your password along with the username and Realm name, and this is compared to the password encrypted using the same algorithm during authentication. The browser doesn't know about your <code>MessageDigest</code> algorithm or salt source, so to encrypt them the same way you need to load a cleartext password from the database.<p class='paragraph'></p>However the plugin does provide an alternative, but it has no configuration options (in particular the digest algorithm cannot be changed). If <code>digest.useCleartextPasswords</code> is <code>false</code> (the default) then the <code>passwordEncoder</code> bean will be replaced with an instance of <code>grails.plugins.springsecurity.DigestAuthPasswordEncoder</code>. This encoder uses the same approach as the browser, i.e. it combines your password along with your username and Realm name essentially as a salt, and encrypting with MD5. MD5 is not recommended in general but given the typical size of the salt it is reasonably safe to use.<p class='paragraph'></p>The only required attribute is <code>useDigestAuth</code> which you must set to <code>true</code>, but you'll probably also want to change the realm name too:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useDigestAuth = <span class='java-keyword'>true</span>
grails.plugins.springsecurity.digest.realmName = <span class='java-quote'>"Ralph's Bait and Tackle"</span></pre></div><p class='paragraph'></p>There are a few other configuration options that you'll be less likely to need to change.<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>digest.realmName</td><td>'Grails Realm'</td><td>The realm name that's displayed in the browser popup</td></tr><tr class='table-even'><td>digest.key</td><td>'changeme'</td><td>A key that's used to build the nonce for authentication; should be changed but that's not required</td></tr><tr class='table-odd'><td>digest.nonceValiditySeconds</td><td>300</td><td>the duration that a nonce stays valid</td></tr><tr class='table-even'><td>digest.passwordAlreadyEncoded</td><td><code>false</code></td><td>whether you're managing the password encryption yourself</td></tr><tr class='table-odd'><td>digest.createAuthenticatedToken</td><td><code>false</code></td><td>if <code>true</code> creates an authenticated <code>UsernamePasswordAuthenticationToken</code> to avoid loading the user from the database twice (but this skips the isAccountNonExpired(), isAccountNonLocked(), isCredentialsNonExpired(), isEnabled() checks so this is not advised)</td></tr><tr class='table-even'><td>digest.useCleartextPasswords</td><td><code>false</code></td><td>if <code>true</code> then a cleartext password encoder will be used (not recommended); if <code>false</code> then passwords encrypted by <code>DigestAuthPasswordEncoder</code> will be stored in the database</td></tr></table><p class='paragraph'></p><p class='paragraph'></p><h2><a name='10.3. Switch User'>10.3. Switch User</a></h2>To enable a user to switch from their current <code>Authentication</code> to another user's, set the <code>useSwitchUserFilter</code> attribute to <code>true</code>. This feature is similar to the 'su' command in Unix, for example to allow an admin to act as a regular user to perform some actions, and then switch back.<p class='paragraph'></p><blockquote class='warning'>
This is a very powerful feature since it allows you full access to whatever the switched-to user can access without knowing their password, so it's very important that you limit who can use this feature. The best way to do this is to guard the user switch URL with a role, e.g. <code>ROLE_SWITCH_USER</code>, <code>ROLE_ADMIN</code>, etc.
</blockquote><p class='paragraph'></p><h4>Switching to another user</h4><p class='paragraph'></p>To switch to another user, typically you would create a form that submits to <code>/j_spring_security_switch_user</code>:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifAllGranted roles='ROLE_SWITCH_USER'&gt;<p class='paragraph'></p>   &lt;form action='/j_spring_security_switch_user' method='POST'&gt;
      Switch to user: &lt;input type='text' name='j_username'/&gt; &lt;br/&gt;
      &lt;input type='submit' value='Switch'/&gt;
   &lt;/form&gt;<p class='paragraph'></p>&lt;/sec:ifAllGranted&gt;</pre></div><p class='paragraph'></p>Note that here the form is guarded by a check that the logged-in user has <code>ROLE_SWITCH_USER</code> and isn't shown otherwise. In addition you'll want to guard the user switch URL and the approach depends on which mapping scheme you're using. If you're using annotations, add a rule to the <code>controllerAnnotations.staticRules</code> attribute:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.controllerAnnotations.staticRules = [
   &#x2026;
   '/j_spring_security_switch_user': ['ROLE_SWITCH_USER', 'IS_AUTHENTICATED_FULLY']
]</pre></div><p class='paragraph'></p>If you're using <code>Requestmap</code>s, create one like this (e.g. in <code>BootStrap</code>):<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>new</span> Requestmap(url: '/j_spring_security_switch_user',
               configAttribute: 'ROLE_SWITCH_USER,IS_AUTHENTICATED_FULLY').save(flush: <span class='java-keyword'>true</span>)</pre></div><p class='paragraph'></p>and if you're using the <code>Config.groovy</code> map, add it there:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.interceptUrlMap = [
   &#x2026;
   '/j_spring_security_switch_user': ['ROLE_SWITCH_USER', 'IS_AUTHENTICATED_FULLY']
]</pre></div><p class='paragraph'></p><h4>Switching back</h4><p class='paragraph'></p>To resume as the original user, navigate to <code>/j_spring_security_exit_user</code>.<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifSwitched&gt;
&lt;a href='${request.contextPath}/j_spring_security_exit_user'&gt;
   Resume as &lt;sec:switchedUserOriginalUsername/&gt;
&lt;/a&gt;
&lt;/sec:ifSwitched&gt;</pre></div><p class='paragraph'></p><h4>Configuration</h4><p class='paragraph'></p>In addition you can customize the URLs that are used for this feature, although this is rarely necessary:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.switchUser.switchUserUrl = &#x2026;
grails.plugins.springsecurity.switchUser.exitUserUrl = &#x2026;
grails.plugins.springsecurity.switchUser.targetUrl = &#x2026;
grails.plugins.springsecurity.switchUser.switchFailureUrl = ...</pre></div><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Name</strong></th><th><strong class='bold'>Default</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>switchUser.switchUserUrl</td><td>'/j_spring_security_switch_user'</td><td>url to access (via GET or POST) to switch to another user</td></tr><tr class='table-even'><td>switchUser.exitUserUrl</td><td>'/j_spring_security_exit_user'</td><td>url to access to switch to another user</td></tr><tr class='table-odd'><td>switchUser.targetUrl</td><td>the same as <code>successHandler.defaultTargetUrl</code></td><td>the URL to redirect to after switching</td></tr><tr class='table-even'><td>switchUser.switchFailureUrl</td><td>the same as <code>failureHandler.defaultFailureUrl</code></td><td>the URL to redirect to after an error attempting to switch</td></tr></table><p class='paragraph'></p><h4>Example code</h4><p class='paragraph'></p>One approach to supporting this feature would be to add code to one or more of your GSP templates. In this example the current username is displayed, and if the user has switched from another (using the <code>sec:ifSwitched</code> tag) then a 'resume' link is displayed. If not, and the user has the required role, then a form is displayed to allow input of the username of the user to switch to:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifLoggedIn&gt;
Logged in as &lt;sec:username/&gt;
&lt;/sec:ifLoggedIn&gt;<p class='paragraph'></p>&lt;sec:ifSwitched&gt;
&lt;a href='${request.contextPath}/j_spring_security_exit_user'&gt;
   Resume as &lt;sec:switchedUserOriginalUsername/&gt;
&lt;/a&gt;
&lt;/sec:ifSwitched&gt;<p class='paragraph'></p>&lt;sec:ifNotSwitched&gt;
   &lt;sec:ifAllGranted roles='ROLE_SWITCH_USER'&gt;<p class='paragraph'></p>   &lt;form action='${request.contextPath}/j_spring_security_switch_user' method='POST'&gt;
      Switch to user: &lt;input type='text' name='j_username'/&gt;&lt;br/&gt;
      &lt;input type='submit' value='Switch'/&gt;
   &lt;/form&gt;<p class='paragraph'></p>   &lt;/sec:ifAllGranted&gt;
&lt;/sec:ifNotSwitched&gt;</pre></div><p class='paragraph'></p><h2><a name='10.4. Session Fixation'>10.4. Session Fixation</a></h2>To guard against <a target='blank' href='http://en.wikipedia.org/wiki/Session_fixation'>session-fixation attacks</a> set the <code>useSessionFixation</code> attribute to <code>true</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useSessionFixation = <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>When this is active, on successful authentication a new HTTP session will be created and the previous session's attributes will be copied into it. This way, if you were to start your session by clicking a link that was generated by someone trying to hack your account which contained an active session id, you would no longer be sharing the previous session after login - you'd have your own.<p class='paragraph'></p>This is less of an issue now that Grails by default does not include jsessionid in URLs (see <a target='blank' href='http://jira.codehaus.org/browse/GRAILS-3364'>this JIRA issue</a>) but it's still a good idea to use this feature regardless.<p class='paragraph'></p>There are a couple of configuration options:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Name</strong></th><th><strong class='bold'>Default Value</strong></th><th>&#xa0;</th></tr><tr class='table-odd'><td>sessionFixation.migrate</td><td><code>true</code></td><td>whether to copy the session attributes of the existing session to the new session after login</td></tr><tr class='table-even'><td>sessionFixation.alwaysCreateSession</td><td><code>false</code></td><td>whether to always create a session even if one didn't exist at the start of the request</td></tr></table><p class='paragraph'></p><h2><a name='10.5. Salted passwords'>10.5. Salted passwords</a></h2>The plugin uses encrypted passwords using whatever digest algorithm you specify, but for enhanced protection against dictionary attacks you should use a salt in addition to digest encryption.<p class='paragraph'></p>There are two approaches to using salted passwords in the plugin - defining a field in the <code>UserDetails</code> class to access by reflection, or by directly implementing <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/dao/SaltSource.html'>SaltSource</a> yourself.<p class='paragraph'></p><h4>dao.reflectionSaltSourceUserProperty</h4><p class='paragraph'></p>For the first approach, you need to set the <code>dao.reflectionSaltSourceUserProperty</code> configuration property, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.dao.reflectionSaltSourceUserProperty = 'username'</pre></div><p class='paragraph'></p>Note that this is a property of the <code>UserDetails</code> class, which by default is an instance of <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code> which extends the standard Spring Security <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html'>User</a>, and not your 'person' domain class. This limits the available fields unless you use a custom <code>UserDetailsService</code> as described <a class='guide' href='../guide/single.html#7. Custom UserDetailsService'>here</a>.<p class='paragraph'></p>As long as the username won't change, it's a good choice for the salt. If you choose a property that the user can change, then they won't be able to log in again after changing it unless you re-encrypt their password with the new value, so it's best to use a property that doesn't change.<p class='paragraph'></p>Another option is to generate a random salt when creating users and store this in the database by adding a new field to the 'person' class. This requires a custom <code>UserDetailsService</code> since you need a custom <code>UserDetails</code> implementation that also has a 'salt' property, but this is more flexible and works in cases where users can change their username.<p class='paragraph'></p><h4>Custom <code>SaltSource</code></h4><p class='paragraph'></p>To have full control over the process, you can implement the <code>SaltSource</code> interface and replace the plugin's implementation with your own by defining a bean in <code>grails-app/conf/spring/resources.groovy</code> with the name <code>saltSource</code>:<p class='paragraph'></p><div class='code'><pre>beans = {
   saltSource(com.foo.bar.MySaltSource) {
      // set properties
   }
}</pre></div><p class='paragraph'></p><h4>Encrypting passwords</h4><p class='paragraph'></p>Regardless of the implementation, you need to be aware of what value to use for a salt when creating or updating users, e.g. in a <code>UserController</code>'s <code>save</code> or <code>update</code> action. Then encrypting the password, you use the two-parameter version of <code>springSecurityService.encodePassword()</code>, e.g.<p class='paragraph'></p><div class='code'><pre>class UserController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def save = {
      def userInstance = <span class='java-keyword'>new</span> User(params)
      userInstance.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      <span class='java-keyword'>if</span> (!userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'create', model: [userInstance: userInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The user was created"</span>
      redirect action: show, id: userInstance.id
   }<p class='paragraph'></p>   def update = {
      def userInstance = User.get(params.id)<p class='paragraph'></p><span class='java-keyword'>if</span> (userInstance.password != params.password) {
         params.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      }
      userInstance.properties = params
      <span class='java-keyword'>if</span> (!userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'edit', model: [userInstance: userInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p><span class='java-keyword'>if</span> (springSecurityService.loggedIn &amp;&amp;
               springSecurityService.principal.username == userInstance.username) {
         springSecurityService.reauthenticate userInstance.username
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The user was updated"</span>
      redirect action: show, id: userInstance.id
   }
}</pre></div><p class='paragraph'></p><h2><a name='10.6. Certificate (X509) login'>10.6. Certificate (X509) login</a></h2>Another authentication mechanism supported by Spring Security is certificate-based, or "mutual authentication". To use this you must use HTTPS and configure the server to require a client certificate (ordinarily only the server provides a certificate). Your username will be extracted from the client certificate if it's valid, and you'll be considered "pre-authenticated". As long as there is a corresponding user in the database with that username, your authentication will succeed and you won't be asked for a password, and the your <code>Authentication</code> will contain the authorities associated with your username.<p class='paragraph'></p>There are a few configuration options available for this feature:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>useX509</td><td><code>false</code></td><td>whether to support certificate-based logins</td></tr><tr class='table-even'><td>x509.continueFilterChainOnUnsuccessfulAuthentication</td><td><code>true</code></td><td>whether to proceed when an authentication attempt fails to allow other authentication mechanisms to process the request</td></tr><tr class='table-odd'><td>x509.subjectDnRegex</td><td>'CN=(.*?),'</td><td>the regex for extracting the username from the certificate's subject name</td></tr><tr class='table-even'><td>x509.checkForPrincipalChanges</td><td><code>false</code></td><td>whether to re-extract the username from the certificate and check that it's still the current user when there's a valid <code>Authentication</code> already</td></tr><tr class='table-odd'><td>x509.invalidateSessionOnPrincipalChange</td><td><code>true</code></td><td>whether to invalidate the session if the principal changed (based on a <code>checkForPrincipalChanges</code> check)</td></tr></table><p class='paragraph'></p>The details around configuring your server for SSL and configuring browser certificates are beyond the scope of this document, but if you're using Tomcat you should look at its <a target='blank' href='http://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html'>SSL documentation</a>. Also, one quick way to get a test environment working is to use the instructions from <a target='blank' href='http://stackoverflow.com/questions/1180397/tomcat-server-client-self-signed-ssl-certificate'>this discussion at Stack Overflow</a>.
<h2><a name='10.7. Channel security'>10.7. Channel security</a></h2>If you are using SSL for some or all of the URLs in your app, you can configure which require HTTP and which require HTTPS using channel security.<p class='paragraph'></p>To configure this, build a Map under the <code>secureChannel.definition</code> key, where the keys are URL patterns, and the values are one of <code>REQUIRES_SECURE_CHANNEL</code>, <code>REQUIRES_INSECURE_CHANNEL</code>, or <code>ANY_CHANNEL</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.secureChannel.definition = [
   '/login/**':         'REQUIRES_SECURE_CHANNEL',
   '/maps/**':          'REQUIRES_INSECURE_CHANNEL',
   '/images/login/**':  'REQUIRES_SECURE_CHANNEL'
   '/images/**':        'ANY_CHANNEL'
]</pre></div><p class='paragraph'></p>URLs will be checked in order, so be sure to put more specific rules before less specific. In the example above <code>/images/login/**</code> is more specific than <code>/images/**</code> so it appears first in the configuration.<p class='paragraph'></p><h2><a name='10.8. IP Address Restrictions'>10.8. IP Address Restrictions</a></h2>Ordinarily it's sufficient to guard URLs with roles, but the plugin provides an extra layer of security with its ability to restrict by IP address. One use for this would be to guard an admin-only part of your site to only be accessible from IP addresses of the local LAN or VPN, e.g. 192.168.1.xxx or 10.xxx.xxx.xxx. This can also be done at your firewall and/or routers, but it can be convenient to have this encapsulated within your application.<p class='paragraph'></p>To use this feature, specify an <code>ipRestrictions</code> configuration map, where the keys are URL patterns, and the values are IP address patterns that can access those URLs. The IP patterns can be single-valued strings, or multi-valued lists of strings and can use <a target='blank' href='http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing'>CIDR</a> masks, and can specify either IPv4 or IPv6 patterns. For example, given this configuration:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.ipRestrictions = [
   '/pattern1/**': '123.234.345.456',
   '/pattern2/**': '10.0.0.0/8',
   '/pattern3/**': ['10.10.200.42', '10.10.200.63']
]</pre></div><p class='paragraph'></p>then <code>pattern1</code> URLs can only be access from the external address 123.234.345.456, <code>pattern2</code> URLs can only be accessed from a 10.xxx.xxx.xxx intranet address, and <code>pattern3</code> URLs can only be accessed from 10.10.200.42 or 10.10.200.63. All other URL patterns are accessible from any IP address.<p class='paragraph'></p>Note that all addresses can always be accessed from localhost regardless of IP pattern, primarily to support local development mode.<p class='paragraph'></p><blockquote class='note'>
You cannot compare IPv4 and IPv6 addresses, so if your server supports both, you need to specify the IP patterns using whichever address format is actually being used, otherwise the filter will throw exceptions. One option is to set the <code>java.net.preferIPv4Stack</code> system property, e.g. by adding it to <code>JAVA_OPTS</code> or <code>GRAILS_OPTS</code> as <code>-Djava.net.preferIPv4Stack=true</code></blockquote><p class='paragraph'></p><h2><a name='10.9. Logout Handlers'>10.9. Logout Handlers</a></h2>Spring Security allows you to register a list of logout handlers (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html'>LogoutHandler</a> interface) that will be called when a user explicitly logs out.<p class='paragraph'></p>By default, a <code>securityContextLogoutHandler</code> bean is registered to clear the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html'>SecurityContextHolder</a>. Also, if you're not using Facebook or OpenID, <code>rememberMeServices</code> bean is registered to reset your cookie (Facebook and OpenID authenticate externally so we don't have access to the password to create a remember-me cookie). If you're using Facebook, a <code>facebookLogoutHandler</code> is registered to reset its session cookies.<p class='paragraph'></p>To customize this list, you define a <code>logout.handlerNames</code> attribute with a list of bean names. The beans must be declared either by the plugin or by you in <code>resources.groovy</code> or <code>resources.xml</code>. So if you have a custom <code>MyLogoutHandler</code> in <code>resources.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myLogoutHandler(com.foo.MyLogoutHandler) {
      // attributes
   }
}</pre></div>
then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.logout.handlerNames = [
   'rememberMeServices', 'securityContextLogoutHandler', 'myLogoutHandler'
]</pre></div><p class='paragraph'></p><h2><a name='10.10. Voters'>10.10. Voters</a></h2>Spring Security allows you to register a list of voters (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/AccessDecisionVoter.html'>AccessDecisionVoter</a> interface) that check that a successful authentication is applicable for the current request. By default a <code>roleVoter</code> bean is registered to ensure users have the required roles for the request, and an <code>authenticatedVoter</code> bean is registered to support <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code> tokens.<p class='paragraph'></p>To customize this list, you define a <code>voterNames</code> attribute with a list of bean names. The beans must be declared either by the plugin, or yourself in resources.groovy or resources.xml. So if you have a custom MyAccessDecisionVoter in resources.groovy, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myAccessDecisionVoter(com.foo.MyAccessDecisionVoter) {
      // attributes
   }
}</pre></div><p class='paragraph'></p>then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.voterNames = [
   'authenticatedVoter', 'roleVoter', 'myAccessDecisionVoter'
]</pre></div><p class='paragraph'></p><h2><a name='10.11. Authentication Providers'>10.11. Authentication Providers</a></h2>The plugin registers authentication providers (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AuthenticationProvider.html'>AuthenticationProvider</a> interface) that perform authentication. By default, three are registered: <code>daoAuthenticationProvider</code> to authenticate using the User and Role database tables, <code>rememberMeAuthenticationProvider</code> to login with a remember-me cookie, and <code>anonymousAuthenticationProvider</code> to create an 'anonymous' authentication if no other provider authenticates.<p class='paragraph'></p>To customize this list, you define a <code>providerNames</code> attribute with a list of bean names. The beans must be declared either by the plugin, or yourself in <code>resources.groovy</code> or <code>resources.xml</code>. So if you have a custom <code>MyAuthenticationProvider</code> in <code>resources.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myAuthenticationProvider(com.foo.MyAuthenticationProvider) {
      // attributes
   }
}</pre></div><p class='paragraph'></p>then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.providerNames = ['myAuthenticationProvider',
                                               'anonymousAuthenticationProvider',
                                               'rememberMeAuthenticationProvider']</pre></div><p class='paragraph'></p><h2><a name='10.12. Hierarchical Roles'>10.12. Hierarchical Roles</a></h2>Hierarchical roles are a convenient way to reduce some clutter in your request mappings. For example, if you have several types of 'admin' roles and any one of them can be used to access some URL pattern, then without using hierarchical roles you need to specify all of them:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SomeController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN', 'ROLE_FINANCE_ADMIN', 'ROLE_SUPERADMIN'])
   def someAction = {
      &#x2026;
   }
}</pre></div><p class='paragraph'></p>But if you have a business rule that says that being granted <code>ROLE_FINANCE_ADMIN</code> implies being granted <code>ROLE_ADMIN</code>, and that being granted <code>ROLE_SUPERADMIN</code> implies being granted <code>ROLE_FINANCE_ADMIN</code>, then you can express that hierarchy as<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.roleHierarchy = '''
   ROLE_SUPERADMIN &gt; ROLE_FINANCE_ADMIN
   ROLE_FINANCE_ADMIN &gt; ROLE_ADMIN
'''</pre></div><p class='paragraph'></p>Then you can simplify your mappings by specifying only the roles that are required:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SomeController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN'])
   def someAction = {
      &#x2026;
   }
}</pre></div><p class='paragraph'></p>You can also reduce the number of granted roles in the database using this approach - where previously you had to grant <code>ROLE_SUPERADMIN</code>, <code>ROLE_FINANCE_ADMIN</code>, and <code>ROLE_ADMIN</code>, now you only need to grant <code>ROLE_SUPERADMIN</code>.<p class='paragraph'></p><h2><a name='10.13. Account Locking and Forcing Password Change'>10.13. Account Locking and Forcing Password Change</a></h2>Spring Security supports four ways of disabling a user account. When you attempt to log in, the <code>UserDetailsService</code> implementation creates an instance of <code>UserDetails</code> which has these accessors:
<ul class='star'><li><code>isAccountNonExpired()</code></li><li><code>isAccountNonLocked()</code></li><li><code>isCredentialsNonExpired()</code></li><li><code>isEnabled()</code></li></ul><p class='paragraph'></p>and if you use the <a class='Scripts' href='../ref/Scripts/s2-quickstart.html'>s2-quickstart</a> script to create a user domain class, it creates a class with corresponding properties to manage this state.<p class='paragraph'></p>When one of these accessors returns <code>false</code> (i.e. <code>accountExpired</code>, <code>accountLocked</code>, or <code>passwordExpired</code> is <code>true</code> or <code>enabled</code> is <code>false</code>)  a corresponding exception is thrown:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Accessor</strong></th><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Exception</strong></th></tr><tr class='table-odd'><td><code>isAccountNonExpired()</code></td><td><code>accountExpired</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AccountExpiredException.html'>AccountExpiredException</a></td></tr><tr class='table-even'><td><code>isAccountNonLocked()</code></td><td><code>accountLocked</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/LockedException.html'>LockedException</a></td></tr><tr class='table-odd'><td><code>isCredentialsNonExpired()</code></td><td><code>passwordExpired</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/CredentialsExpiredException.html'>CredentialsExpiredException</a></td></tr><tr class='table-even'><td><code>isEnabled()</code></td><td><code>enabled</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/DisabledException.html'>DisabledException</a></td></tr></table><p class='paragraph'></p>You can configure an exception mapping in <code>Config.groovy</code> to associate a URL to any or all of these exceptions to determine where to redirect after a failure, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.failureHandler.exceptionMappings = [
   'org.springframework.security.authentication.LockedException':             '/user/accountLocked',
   'org.springframework.security.authentication.DisabledException':           '/user/accountDisabled',
   'org.springframework.security.authentication.AccountExpiredException':     '/user/accountExpired',
   'org.springframework.security.authentication.CredentialsExpiredException': '/user/passwordExpired'
]</pre></div><p class='paragraph'></p>Without a mapping for a particular exception, the user will be redirected to the standard login fail page (by default <code>/login/authfail</code>) like they would if they had entered a bad password, but they'll see an error message from this table:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default</strong></th></tr><tr class='table-odd'><td>errors.login.disabled</td><td>"Sorry, your account is disabled."</td></tr><tr class='table-even'><td>errors.login.expired</td><td>"Sorry, your account has expired."</td></tr><tr class='table-odd'><td>errors.login.passwordExpired</td><td>"Sorry, your password has expired."</td></tr><tr class='table-even'><td>errors.login.locked</td><td>"Sorry, your account is locked."</td></tr><tr class='table-odd'><td>errors.login.fail</td><td>"Sorry, we were not able to find a user with that username and password."</td></tr></table><p class='paragraph'></p>Any of these can be customized by setting the corresponding property in <code>Config.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.errors.login.locked = <span class='java-quote'>"None shall pass."</span></pre></div><p class='paragraph'></p>You can use this functionality to manually lock a user's account or expire the password, but another option would be to automate the process. For example you could use the <a target='blank' href='http://grails.org/plugin/quartz'>Quartz plugin</a> to periodically expire everyone's password and force them to go to a page where they update it. You could also keep track of the date when the users change their passwords and use a Quartz job to expire their passwords once the password is older than some fixed max age.<p class='paragraph'></p><h4>User cache</h4><p class='paragraph'></p>If configured, Spring Security will cache <code>UserDetails</code> instances to save trips to the database. This is managed by the <code>cacheUsers</code> configuration property, and it defaults to <code>false</code> in the plugin but you can enable it if you wish. In general this is a minor optimization since there will most likely be only two small queries during login; one to load the user, and one to load the authorities.<p class='paragraph'></p>If you enable this feature, you must remove any cached instances after making a change that affects login. If you don't, even though a user's account is locked or disabled, logins will still succeed since the database will be bypassed. By removing the cached data, you force them to go to the database and retrieve the latest updates.<p class='paragraph'></p>Here is a sample Quartz job that demonstrates how you might find and disable users with passwords that are too old:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p>class ExpirePasswordsJob  {<p class='paragraph'></p><span class='java-keyword'>static</span> triggers = {
      cron name: 'myTrigger', cronExpression: '0 0 0 * * ?' // midnight daily
   }<p class='paragraph'></p>   def userCache<p class='paragraph'></p>   void execute() {<p class='paragraph'></p>      def users = User.executeQuery(
            'from User u where u.passwordChangeDate &lt;= :cutoffDate',
            [cutoffDate: <span class='java-keyword'>new</span> Date() - 180])<p class='paragraph'></p><span class='java-keyword'>for</span> (user in users) {
         // flush each separately so one failure doesn't rollback all of the others
         <span class='java-keyword'>try</span> {
            user.passwordExpired = <span class='java-keyword'>true</span>
            user.save(flush: <span class='java-keyword'>true</span>)
            userCache.removeUserFromCache user.username
         }
         <span class='java-keyword'>catch</span> (e) {
            log.error <span class='java-quote'>"problem expiring password <span class='java-keyword'>for</span> user $user.username : $e.message"</span>, e
         }
      }
   }
}</pre></div><p class='paragraph'></p><h2><a name='10.13. Remember-me'>10.13. Remember-me</a></h2>Spring Security supports creating a remember-me cookie so users aren't required to login with a username and password for each session. This is optional and is usually implemented as a checkbox on the login form; the default <code>auth.gsp</code> supplied by the plugin has this feature.<p class='paragraph'></p>There are a few configuration attributes related to remember-me:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>rememberMe.cookieName</td><td>'grails_remember_me'</td><td>remember-me cookie name - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.alwaysRemember</td><td><code>false</code></td><td>create a remember-me cookie even if there's no checkbox on the form if <code>true</code></td></tr><tr class='table-odd'><td>rememberMe.tokenValiditySeconds</td><td>1209600 (14 days)</td><td>max age of the cookie in seconds</td></tr><tr class='table-even'><td>rememberMe.parameter</td><td>'_spring_security_remember_me'</td><td>Login form remember-me checkbox name</td></tr><tr class='table-odd'><td>rememberMe.key</td><td>'grailsRocks'</td><td>a value used to encode cookies - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.persistent</td><td><code>false</code></td><td>if <code>true</code> store persistent login information in the database</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.domainClassName</td><td>'PersistentLogin'</td><td>domain class used to manage persistent logins</td></tr><tr class='table-even'><td>rememberMe.persistentToken.seriesLength</td><td>16</td><td>the number of characters in the cookie's <code>series</code> attribute</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.tokenLength</td><td>16</td><td>the number of characters in the cookie's <code>token</code> attribute</td></tr><tr class='table-even'><td>atr.rememberMeClass</td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/RememberMeAuthenticationToken.html'>RememberMeAuthenticationToken</a></td><td>remember-me authentication class</td></tr></table><p class='paragraph'></p>Three attributes that you're most likely to change are
<ul class='star'><li><code>rememberMe.cookieName</code> - this is purely aesthetic since most users won't look at their cookies, but you probably want the name displayed to be something application-specific and not "grails_remember_me"</li><li><code>rememberMe.key</code> - this is used as part of a salt when encrypting the cookie, so changing it from the default will make it that much harder to do brute force attacks</li><li><code>rememberMe.tokenValiditySeconds</code> - the default is two weeks, but you can set it to whatever makes sense for your application</li></ul><p class='paragraph'></p><h4>Persistent logins</h4><p class='paragraph'></p>The remember-me cookie is very secure but for an even stronger solution you can use persistent logins that store the username in the database. See the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/reference/remember-me.html'>Spring Security docs</a> for a description of the implementation.<p class='paragraph'></p>This is also useful for authentication schemes like OpenID and Facebook, where you don't manage passwords in your database, but most of the other user information is stored locally. Without a password you can't use the standard cookie format, so persistent logins enable remember-me cookies in these scenarios.<p class='paragraph'></p>To use this feature, run the <a class='Scripts' href='../ref/Scripts/s2-create-persistent-token.html'>s2-create-persistent-token</a> script. This will create the domain class, and register its name in <code>grails-app/conf/Config.groovy</code>. It will also enable persistent logins by setting <code>rememberMe.persistent</code> to <code>true</code>.

        </div><div id='footer'></div>
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body></html>