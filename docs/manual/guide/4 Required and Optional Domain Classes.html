<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4 Required and Optional Domain Classes</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4 Required and Optional Domain Classes">4 Required and Optional Domain Classes</a></h1>By default the plugin uses regular Grails domain classes to access its required data. It's easy to create your own user lookup code though, which can access the database or any other source to retrieve user and authority data. See <a href="../guide/single.html#11 Custom UserDetailsService" class="guide">Custom UserDetailsService</a> for how to implement this.<p class="paragraph"/>To use the standard user lookup you'll need at a minimum a 'person' and an 'authority' domain class. In addition, if you want to store URL&#60;-&#62;Role mappings in the database (this is one of multiple approaches for defining the mappings) you need a 'requestmap' domain class. If you use the recommended approach for mapping the many-to-many relationship between 'person' and 'authority,' you also need a domain class to map the join table.<p class="paragraph"/>The <a href="../ref/Scripts/s2-quickstart.html" class="Scripts">s2-quickstart</a> script creates initial domain classes for you. You specify the package and class names, and it creates the corresponding domain classes. After that you can customize them as you like. You can add unlimited fields, methods, and so on, as long as the core security-related functionality remains.
<h2><a name="4.1 Person Class">4.1 Person Class</a></h2>Spring Security uses an <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/Authentication.html" target="blank">Authentication</a> object to determine whether the current user has the right to perform a secured action, such as accessing a URL, manipulating a secured domain object, accessing a secured method, and so on. This object is created during login. Typically overlap occurs between the need for authentication data and the need to represent a user in the application in ways that are unrelated to security. The mechanism for populating the authentication is completely pluggable in Spring Security; you only need to provide an implementation of <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/UserDetailsService.html" target="blank">UserDetailsService</a> and implement its one method, <code>loadUserByUsername()</code>.<p class="paragraph"/>By default the plugin uses a Grails 'person' domain class to manage this data. The class name is <code>Person</code>, and <code>username</code>, <code>enabled</code>, <code>password</code> are the default names of the required properties. You can easily <a href="../guide/single.html#11 Custom UserDetailsService" class="guide">plug in your own implementation</a>, and rename the class, package, and fields. In addition, you should define an <code>authorities</code> property to retrieve roles; this can be a public field or a <code>getAuthorities()</code> method, and it can be defined through a traditional GORM many-to-many or a custom mapping.<p class="paragraph"/>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>User</code> as your class name, you'll generate this class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.mycompany.myapp<p class="paragraph"/>class User &#123;<p class="paragraph"/>   <span class="java&#45;object">String</span> username
   <span class="java&#45;object">String</span> password
   <span class="java&#45;object">boolean</span> enabled
   <span class="java&#45;object">boolean</span> accountExpired
   <span class="java&#45;object">boolean</span> accountLocked
   <span class="java&#45;object">boolean</span> passwordExpired<p class="paragraph"/>   <span class="java&#45;keyword">static</span> constraints = &#123;
      username blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>
      password blank: <span class="java&#45;keyword">false</span>
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> mapping = &#123;
      password column: '`password`'
   &#125;<p class="paragraph"/>   Set&#60;Role&#62; getAuthorities() &#123;
      UserRole.findAllByUser(<span class="java&#45;keyword">this</span>).collect &#123; it.role &#125; as Set
   &#125;
&#125;</pre></div><p class="paragraph"/>Optionally, add other properties such as <code>email</code>, <code>firstName</code>, <code>lastName</code>, and convenience methods, and so on:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.mycompany.myapp<p class="paragraph"/>class User &#123;<p class="paragraph"/>   <span class="java&#45;object">String</span> username
   <span class="java&#45;object">String</span> password
   <span class="java&#45;object">boolean</span> enabled
   <span class="java&#45;object">String</span> email
   <span class="java&#45;object">String</span> firstName
   <span class="java&#45;object">String</span> lastName<p class="paragraph"/>   <span class="java&#45;keyword">static</span> constraints = &#123;
      username blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>
      password blank: <span class="java&#45;keyword">false</span>
   &#125;<p class="paragraph"/>   Set&#60;Role&#62; getAuthorities() &#123;
      UserRole.findAllByUser(<span class="java&#45;keyword">this</span>).collect &#123; it.role &#125; as Set
   &#125;<p class="paragraph"/>   def someMethod &#123;
      &#8230;
   &#125;
&#125;</pre></div><p class="paragraph"/>The <code>getAuthorities()</code> method is analagous to defining <code>static hasMany = &#91;authorities: Authority&#93;</code> in a traditional many-to-many mapping. This way <code>GormUserDetailsService</code> can call <code>user.authorities</code> during login to retrieve the roles without the overhead of a bidirectional many-to-many mapping.<p class="paragraph"/>The class and property names are configurable using these configuration attributes:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default Value</strong></th><th><strong class="bold">Meaning</strong></th></tr><tr class="table-odd"><td>userLookup.userDomainClassName</td><td>'Person'</td><td>User class name</td></tr><tr class="table-even"><td>userLookup.usernamePropertyName</td><td>'username'</td><td>User class username field</td></tr><tr class="table-odd"><td>userLookup.passwordPropertyName</td><td>'password'</td><td>User class password field</td></tr><tr class="table-even"><td>userLookup.authoritiesPropertyName</td><td>'authorities'</td><td>User class role collection field</td></tr><tr class="table-odd"><td>userLookup.enabledPropertyName</td><td>'enabled'</td><td>User class enabled field</td></tr><tr class="table-even"><td>userLookup.accountExpiredPropertyName</td><td>'accountExpired'</td><td>User class account expired field</td></tr><tr class="table-odd"><td>userLookup.accountLockedPropertyName</td><td>'accountLocked'</td><td>User class account locked field</td></tr><tr class="table-even"><td>userLookup.passwordExpiredPropertyName</td><td>'passwordExpired'</td><td>User class password expired field</td></tr><tr class="table-odd"><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr></table>
<h2><a name="4.2 Authority Class">4.2 Authority Class</a></h2>The Spring Security plugin also requires an 'authority' class to represent a user's role(s) in the application. In general this class restricts URLs to users who have been assigned the required access rights. A user can have multiple roles to indicate various access rights in the application, and should have at least one. A basic user who can access only non-restricted resources but can still authenticate is a bit unusual. Spring Security usually functions fine if a user has no granted authorities, but fails in a few places that assume one or more. So if a user authenticates successfully but has no granted roles, the plugin grants the user a 'virtual' role, <code>ROLE_NO_ROLES</code>. Thus the user satisfies Spring Security's requirements but cannot access secure resources, as you would not associate any secure resources with this role.<p class="paragraph"/>Like the 'person' class, the 'authority' class has a default name, <code>Authority</code>, and a default name for its one required property, <code>authority</code>.
If you want to use another existing domain class, it simply has to have a property for name. As with the name of the class, the names of the properties can be whatever you want - they're specified in <code>grails-app/conf/Config.groovy</code>.<p class="paragraph"/>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>Role</code> as your class name, you'll generate this class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.mycompany.myapp<p class="paragraph"/>class Role &#123;<p class="paragraph"/>   <span class="java&#45;object">String</span> authority<p class="paragraph"/>   <span class="java&#45;keyword">static</span> mapping = &#123;
      cache <span class="java&#45;keyword">true</span>
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> constraints = &#123;
      authority blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>The class and property names are configurable using these configuration attributes:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default Value</strong></th><th><strong class="bold">Meaning</strong></th></tr><tr class="table-odd"><td>authority.className</td><td>'Authority'</td><td>Role class name</td></tr><tr class="table-even"><td>authority.nameField</td><td>'authority'</td><td>Role class role name field</td></tr></table>
<h2><a name="4.3 PersonAuthority Class">4.3 PersonAuthority Class</a></h2>The typical approach to mapping the relationship between 'person' and 'authority' is a many-to-many. Users have multiple roles, and roles are shared by multiple users. This approach can be problematic in Grails, because a popular role, for example, <code>ROLE_USER</code>, will be granted to many users in your application. GORM uses collections to manage adding and removing related instances and maps many-to-many relationships bidirectionally. Granting a role to a user requires loading all  existing users who have that role because the collection is a <code>Set</code>. So even though no uniqueness concerns may exist, Hibernate loads them all to enforce uniqueness. The recommended approach in the plugin is to map a domain class to the join table that manages the many-to-many, and using that to grant and revoke roles to users.<p class="paragraph"/>Like the other domain classes, this class is generated for you, so you don't need to deal with the details of mapping it. Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>User</code> and <code>Role</code> as your class names, you'll generate this class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.testapp<p class="paragraph"/><span class="java&#45;keyword">import</span> org.apache.commons.lang.builder.HashCodeBuilder<p class="paragraph"/>class UserRole <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>   User user
   Role role<p class="paragraph"/>   <span class="java&#45;object">boolean</span> equals(other) &#123;
      <span class="java&#45;keyword">if</span> (!(other <span class="java&#45;keyword">instanceof</span> UserRole)) &#123;
         <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>
      &#125;<p class="paragraph"/>      other.user?.id == user?.id &#38;&#38;
         other.role?.id == role?.id
   &#125;<p class="paragraph"/>   <span class="java&#45;object">int</span> hashCode() &#123;
      def builder = <span class="java&#45;keyword">new</span> HashCodeBuilder()
      <span class="java&#45;keyword">if</span> (user) builder.append(user.id)
      <span class="java&#45;keyword">if</span> (role) builder.append(role.id)
      builder.toHashCode()
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> UserRole get(<span class="java&#45;object">long</span> userId, <span class="java&#45;object">long</span> roleId) &#123;
      find 'from UserRole where user.id=:userId and role.id=:roleId',
         &#91;userId: userId, roleId: roleId&#93;
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> UserRole create(User user, Role role, <span class="java&#45;object">boolean</span> flush = <span class="java&#45;keyword">false</span>) &#123;
      <span class="java&#45;keyword">new</span> UserRole(user: user, role: role).save(flush: flush, insert: <span class="java&#45;keyword">true</span>)
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> <span class="java&#45;object">boolean</span> remove(User user, Role role, <span class="java&#45;object">boolean</span> flush = <span class="java&#45;keyword">false</span>) &#123;
      UserRole instance = UserRole.findByUserAndRole(user, role)
      <span class="java&#45;keyword">if</span> (!instance) &#123;
         <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">false</span>
      &#125;<p class="paragraph"/>      instance.delete(flush: flush)
      <span class="java&#45;keyword">true</span>
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> void removeAll(User user) &#123;
      executeUpdate 'DELETE FROM UserRole WHERE user=:user', &#91;user: user&#93;
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> mapping = &#123;
      id composite: &#91;'role', 'user'&#93;
      version <span class="java&#45;keyword">false</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>The helper methods make it easy to grant or revoke roles. Assuming you have already loaded a user and a role, you grant the role to the user as follows:<p class="paragraph"/><div class="code"><pre>User user = &#8230;
Role role = &#8230;
UserRole.create user, role</pre></div><p class="paragraph"/>Or by using the 3-parameter version to trigger a flush:<p class="paragraph"/><div class="code"><pre>User user = &#8230;
Role role = &#8230;
UserRole.create user, role, <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>Revoking a role is similar:<p class="paragraph"/><div class="code"><pre>User user = &#8230;
Role role = &#8230;
UserRole.remove user, role</pre></div><p class="paragraph"/>Or:<p class="paragraph"/><div class="code"><pre>User user = &#8230;
Role role = &#8230;
UserRole.remove user, role, <span class="java&#45;keyword">true</span></pre></div><p class="paragraph"/>The class name is the only configurable attribute:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default Value</strong></th><th><strong class="bold">Meaning</strong></th></tr><tr class="table-odd"><td>userLookup.authorityJoinClassName</td><td>'PersonAuthority'</td><td>User/Role many-many join class name</td></tr></table>
<h2><a name="4.4 Requestmap Class">4.4 Requestmap Class</a></h2>Optionally, use this class to store request mapping entries in the database instead of defining them with annotations or in <code>Config.groovy</code>. This option makes  the class configurable at runtime; you can add, remove and edit rules without restarting your application.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Property</strong></th><th><strong class="bold">Default Value</strong></th><th><strong class="bold">Meaning</strong></th></tr><tr class="table-odd"><td>requestMap.className</td><td>'Requestmap'</td><td>requestmap class name</td></tr><tr class="table-even"><td>requestMap.urlField</td><td>'url'</td><td>URL pattern field name</td></tr><tr class="table-odd"><td>requestMap.configAttributeField</td><td>'configAttribute'</td><td>authority pattern field name</td></tr></table><p class="paragraph"/>Assuming you choose <code>com.mycompany.myapp</code> as your package, and <code>Requestmap</code> as your class name, you'll generate this class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> com.testapp<p class="paragraph"/>class Requestmap &#123;<p class="paragraph"/>   <span class="java&#45;object">String</span> url
   <span class="java&#45;object">String</span> configAttribute<p class="paragraph"/>   <span class="java&#45;keyword">static</span> mapping = &#123;
      cache <span class="java&#45;keyword">true</span>
   &#125;<p class="paragraph"/>   <span class="java&#45;keyword">static</span> constraints = &#123;
      url blank: <span class="java&#45;keyword">false</span>, unique: <span class="java&#45;keyword">true</span>
      configAttribute blank: <span class="java&#45;keyword">false</span>
   &#125;
&#125;</pre></div><p class="paragraph"/>To use Requestmap entries to guard URLs, see <a href="../guide/single.html#5.3 Requestmap Instances Stored in the Database" class="guide">Requestmap Instances Stored in the Database</a>.

    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body>
</html>
