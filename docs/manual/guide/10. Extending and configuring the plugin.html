<html><head><meta content='text/html; charset=utf-8' http-equiv='Content-type'></meta><title>10. Extending and configuring the plugin</title><link title='Ref' charset='utf-8' rel='stylesheet' type='text/css' href='../css/main.css' media='screen'></link></head><body><body class='body'><h1><a name='10. Extending and configuring the plugin'>10. Extending and configuring the plugin</a></h1><h2><a name='10.1. Filters'>10.1. Filters</a></h2>There are a few different approaches to configuring filter chain(s). The default way is to use configuration attributes to determine which extra filters to use (e.g. Basic Auth, Switch User, etc.) and add these to the 'core' filters. For example, setting <code>grails.plugins.springsecurity.useSwitchUserFilter = true</code> adds <code>switchUserProcessingFilter</code> to the filter chain (and in the correct order). The filter chain built here is applied to all URLs, so if you need more flexibility then you further refine it using <code>filterChain.chainMap</code> as discussed below.<p class='paragraph'></p><h4>filterNames</h4><p class='paragraph'></p>To define custom filters, remove a core filter from the chain (not recommended), or otherwise have control over the filter chain, you can specify the <code>filterNames</code> property as a list of strings, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.filterNames = [
   'httpSessionContextIntegrationFilter', 'logoutFilter', 'authenticationProcessingFilter',
   'myCustomProcessingFilter', 'rememberMeProcessingFilter', 'anonymousProcessingFilter',
   'exceptionTranslationFilter', 'filterInvocationInterceptor'
]</pre></div><p class='paragraph'></p>This will create a filter chain corresponding to the Spring beans with the specified names. As with the default approach, the filter chain built here is applied to all URLs.<p class='paragraph'></p><h4>chainMap</h4><p class='paragraph'></p>You can also define which filters to applied to different URL patterns using the <code>filterChain.chainMap</code> attribute. This involves defining a Map which specifies one or more lists of filter bean names, each with a corresponding URL pattern, e.g.:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.filterChain.chainMap = [
   '/urlpattern1/**': 'filter1,filter2,filter3,filter4',
   '/urlpattern2/**': 'filter1,filter3,filter5',
   '/**': 'JOINED_FILTERS',
]</pre></div><p class='paragraph'></p>In this example, four filters are applied to URLs matching <code>/urlpattern1/**</code> and three different filters are applied to URLs matching <code>/urlpattern2/**</code>. In addition the special token <code>JOINED_FILTERS</code> is applied to all URLs. This is a conventient way to specify that all defined filters (configured either with configuration rules like <code>useSwitchUserFilter</code> or explicitly using <code>filterNames</code>) should apply to this pattern.<p class='paragraph'></p>Note that the order of the mappings is important. Each URL will be tested in order from top to bottom to find the first matching one. So we need a <code>/**</code> catch-all rule at the end for URLs that aren't don't match one of the earlier rules.<p class='paragraph'></p><h4>clientRegisterFilter</h4><p class='paragraph'></p>An alternative to setting the <code>filterNames</code> property is <code>org.codehaus.groovy.grails.plugins.springsecurity.SpringSecurityUtils.clientRegisterFilter()</code>. This allows you to add a custom filter to the chain at a specified position. Each of the standard filters has a corresponding position in the chain (see <code>org.codehaus.groovy.grails.plugins.springsecurity.SecurityFilterPosition</code> for details). So if you have created an application-specific filter, register it in <code>grails-app/conf/spring/resources.groovy</code>:<p class='paragraph'></p><div class='code'><pre>beans = {
   myFilter(com.mycompany.myapp.MyFilter) {
      // properties
   }
}</pre></div><p class='paragraph'></p>and then register it in <code>grails-app/conf/BootStrap.groovy</code>:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>import</span> org.codehaus.groovy.grails.plugins.springsecurity.SecurityFilterPosition
<span class='java-keyword'>import</span> org.codehaus.groovy.grails.plugins.springsecurity.SpringSecurityUtils<p class='paragraph'></p>class BootStrap {<p class='paragraph'></p>   def init = { servletContext -&gt;
      SpringSecurityUtils.clientRegisterFilter(
          'myFilter', SecurityFilterPosition.OPENID_FILTER.order + 10)
   }
}</pre></div><p class='paragraph'></p>This bootstrap code will register your filter just after the Open ID filter (if it's configured). You cannot register a filter in the same position as another, so it's a good idea to add a small delta to its position to put it after or before a filter that it should be next to in the chain. Note that the Open ID filter position is just an example - add your filter in whatever position makes sense.
<h2><a name='10.2. Basic and Digest Auth'>10.2. Basic and Digest Auth</a></h2><h4>Basic Auth</h4>
To use <a target='blank' href='http://en.wikipedia.org/wiki/Basic_access_authentication'>HTTP Basic Authentication</a> in your application set the <code>useBasicAuth</code> attribute to <code>true</code>. You should also change the <code>basic.realmName</code> from its default value to one that's appropriate for your application, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useBasicAuth = <span class='java-keyword'>true</span>
grails.plugins.springsecurity.basic.realmName = <span class='java-quote'>"Ralph's Bait and Tackle"</span></pre></div><p class='paragraph'></p>With this in place, users will be prompted with the standard browser login dialog instead of being redirected to a login page.<p class='paragraph'></p><h4>Digest Auth</h4><p class='paragraph'></p><a target='blank' href='http://en.wikipedia.org/wiki/Digest_access_authentication'>Digest Authentication</a> is similar to Basic auth but is more secure in that it doesn't send your password in obfuscated cleartext. It looks just like Basic auth in practice - you get the same browser popup dialog when you authenticate. But since the credential transfer is genuinely encrypted (instead of just Base64-encoded as with Basic auth) you don't need to use SSL to guard your logins.<p class='paragraph'></p>There is one issue with using Digest auth - by default you must store cleartext passwords in your database. This is because the browser encrypts your password along with the username and Realm name, and this is compared to the password encrypted using the same algorithm during authentication. The browser doesn't know about your <code>MessageDigest</code> algorithm or salt source, so to encrypt them the same way you need to load a cleartext password from the database.<p class='paragraph'></p>However the plugin does provide an alternative, but it has no configuration options (in particular the digest algorithm cannot be changed). If <code>digest.useCleartextPasswords</code> is <code>false</code> (the default) then the <code>passwordEncoder</code> bean will be replaced with an instance of <code>grails.plugins.springsecurity.DigestAuthPasswordEncoder</code>. This encoder uses the same approach as the browser, i.e. it combines your password along with your username and Realm name essentially as a salt, and encrypting with MD5. MD5 is not recommended in general but given the typical size of the salt it is reasonably safe to use.<p class='paragraph'></p>The only required attribute is <code>useDigestAuth</code> which you must set to <code>true</code>, but you'll probably also want to change the realm name too:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useDigestAuth = <span class='java-keyword'>true</span>
grails.plugins.springsecurity.digest.realmName = <span class='java-quote'>"Ralph's Bait and Tackle"</span></pre></div><p class='paragraph'></p>There are a few other configuration options that you'll be less likely to need to change.<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>digest.realmName</td><td>'Grails Realm'</td><td>The realm name that's displayed in the browser popup</td></tr><tr class='table-even'><td>digest.key</td><td>'changeme'</td><td>A key that's used to build the nonce for authentication; should be changed but that's not required</td></tr><tr class='table-odd'><td>digest.nonceValiditySeconds</td><td>300</td><td>the duration that a nonce stays valid</td></tr><tr class='table-even'><td>digest.passwordAlreadyEncoded</td><td><code>false</code></td><td>whether you're managing the password encryption yourself</td></tr><tr class='table-odd'><td>digest.createAuthenticatedToken</td><td><code>false</code></td><td>if <code>true</code> creates an authenticated <code>UsernamePasswordAuthenticationToken</code> to avoid loading the user from the database twice (but this skips the isAccountNonExpired(), isAccountNonLocked(), isCredentialsNonExpired(), isEnabled() checks so this is not advised)</td></tr><tr class='table-even'><td>digest.useCleartextPasswords</td><td><code>false</code></td><td>if <code>true</code> then a cleartext password encoder will be used (not recommended); if <code>false</code> then passwords encrypted by <code>DigestAuthPasswordEncoder</code> will be stored in the database</td></tr></table><p class='paragraph'></p><p class='paragraph'></p><h2><a name='10.3. Switch User'>10.3. Switch User</a></h2>To enable a user to switch from their current <code>Authentication</code> to another user's, set the <code>useSwitchUserFilter</code> attribute to <code>true</code>. This feature is similar to the 'su' command in Unix, for example to allow an admin to act as a regular user to perform some actions, and then switch back.<p class='paragraph'></p><blockquote class='warning'>
This is a very powerful feature since it allows you full access to whatever the switched-to user can access without knowing their password, so it's very important that you limit who can use this feature. The best way to do this is to guard the user switch URL with a role, e.g. <code>ROLE_SWITCH_USER</code>, <code>ROLE_ADMIN</code>, etc.
</blockquote><p class='paragraph'></p><h4>Switching to another user</h4><p class='paragraph'></p>To switch to another user, typically you would create a form that submits to <code>/j_spring_security_switch_user</code>:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifAllGranted roles='ROLE_SWITCH_USER'&gt;<p class='paragraph'></p>   &lt;form action='/j_spring_security_switch_user' method='POST'&gt;
      Switch to user: &lt;input type='text' name='j_username'/&gt; &lt;br/&gt;
      &lt;input type='submit' value='Switch'/&gt;
   &lt;/form&gt;<p class='paragraph'></p>&lt;/sec:ifAllGranted&gt;</pre></div><p class='paragraph'></p>Note that here the form is guarded by a check that the logged-in user has <code>ROLE_SWITCH_USER</code> and isn't shown otherwise. In addition you'll want to guard the user switch URL and the approach depends on which mapping scheme you're using. If you're using annotations, add a rule to the <code>controllerAnnotations.staticRules</code> attribute:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.controllerAnnotations.staticRules = [
   &#x2026;
   '/j_spring_security_switch_user': ['ROLE_SWITCH_USER', 'IS_AUTHENTICATED_FULLY']
]</pre></div><p class='paragraph'></p>If you're using <code>Requestmap</code>s, create one like this (e.g. in <code>BootStrap</code>):<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>new</span> Requestmap(url: '/j_spring_security_switch_user',
               configAttribute: 'ROLE_SWITCH_USER,IS_AUTHENTICATED_FULLY').save(flush: <span class='java-keyword'>true</span>)</pre></div><p class='paragraph'></p>and if you're using the <code>Config.groovy</code> map, add it there:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.interceptUrlMap = [
   &#x2026;
   '/j_spring_security_switch_user': ['ROLE_SWITCH_USER', 'IS_AUTHENTICATED_FULLY']
]</pre></div><p class='paragraph'></p><h4>Switching back</h4><p class='paragraph'></p>To resume as the original user, navigate to <code>/j_spring_security_exit_user</code>.<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifSwitched&gt;
&lt;a href='${request.contextPath}/j_spring_security_exit_user'&gt;
   Resume as &lt;sec:switchedUserOriginalUsername/&gt;
&lt;/a&gt;
&lt;/sec:ifSwitched&gt;</pre></div><p class='paragraph'></p><h4>Configuration</h4><p class='paragraph'></p>In addition you can customize the URLs that are used for this feature, although this is rarely necessary:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.switchUser.switchUserUrl = &#x2026;
grails.plugins.springsecurity.switchUser.exitUserUrl = &#x2026;
grails.plugins.springsecurity.switchUser.targetUrl = &#x2026;
grails.plugins.springsecurity.switchUser.switchFailureUrl = ...</pre></div><p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Name</strong></th><th><strong class='bold'>Default</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>switchUser.switchUserUrl</td><td>'/j_spring_security_switch_user'</td><td>url to access (via GET or POST) to switch to another user</td></tr><tr class='table-even'><td>switchUser.exitUserUrl</td><td>'/j_spring_security_exit_user'</td><td>url to access to switch to another user</td></tr><tr class='table-odd'><td>switchUser.targetUrl</td><td>the same as <code>successHandler.defaultTargetUrl</code></td><td>the URL to redirect to after switching</td></tr><tr class='table-even'><td>switchUser.switchFailureUrl</td><td>the same as <code>failureHandler.defaultFailureUrl</code></td><td>the URL to redirect to after an error attempting to switch</td></tr></table><p class='paragraph'></p><h4>Example code</h4><p class='paragraph'></p>One approach to supporting this feature would be to add code to one or more of your GSP templates. In this example the current username is displayed, and if the user has switched from another (using the <code>sec:ifSwitched</code> tag) then a 'resume' link is displayed. If not, and the user has the required role, then a form is displayed to allow input of the username of the user to switch to:<p class='paragraph'></p><div class='code'><pre>&lt;sec:ifLoggedIn&gt;
Logged in as &lt;sec:username/&gt;
&lt;/sec:ifLoggedIn&gt;<p class='paragraph'></p>&lt;sec:ifSwitched&gt;
&lt;a href='${request.contextPath}/j_spring_security_exit_user'&gt;
   Resume as &lt;sec:switchedUserOriginalUsername/&gt;
&lt;/a&gt;
&lt;/sec:ifSwitched&gt;<p class='paragraph'></p>&lt;sec:ifNotSwitched&gt;
   &lt;sec:ifAllGranted roles='ROLE_SWITCH_USER'&gt;<p class='paragraph'></p>   &lt;form action='${request.contextPath}/j_spring_security_switch_user' method='POST'&gt;
      Switch to user: &lt;input type='text' name='j_username'/&gt;&lt;br/&gt;
      &lt;input type='submit' value='Switch'/&gt;
   &lt;/form&gt;<p class='paragraph'></p>   &lt;/sec:ifAllGranted&gt;
&lt;/sec:ifNotSwitched&gt;</pre></div><p class='paragraph'></p><h2><a name='10.4. Session Fixation'>10.4. Session Fixation</a></h2>To guard against <a target='blank' href='http://en.wikipedia.org/wiki/Session_fixation'>session-fixation attacks</a> set the <code>useSessionFixation</code> attribute to <code>true</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.useSessionFixation = <span class='java-keyword'>true</span></pre></div><p class='paragraph'></p>When this is active, on successful authentication a new HTTP session will be created and the previous session's attributes will be copied into it. This way, if you were to start your session by clicking a link that was generated by someone trying to hack your account which contained an active session id, you would no longer be sharing the previous session after login - you'd have your own.<p class='paragraph'></p>This is less of an issue now that Grails by default does not include jsessionid in URLs (see <a target='blank' href='http://jira.codehaus.org/browse/GRAILS-3364'>this JIRA issue</a>) but it's still a good idea to use this feature regardless.<p class='paragraph'></p>There are a couple of configuration options:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Name</strong></th><th><strong class='bold'>Default Value</strong></th><th>&#xa0;</th></tr><tr class='table-odd'><td>sessionFixation.migrate</td><td><code>true</code></td><td>whether to copy the session attributes of the existing session to the new session after login</td></tr><tr class='table-even'><td>sessionFixation.alwaysCreateSession</td><td><code>false</code></td><td>whether to always create a session even if one didn't exist at the start of the request</td></tr></table><p class='paragraph'></p><h2><a name='10.5. Salted passwords'>10.5. Salted passwords</a></h2>The plugin uses encrypted passwords using whatever digest algorithm you specify, but for enhanced protection against dictionary attacks you should use a salt in addition to digest encryption.<p class='paragraph'></p>There are two approaches to using salted passwords in the plugin - defining a field in the <code>UserDetails</code> class to access by reflection, or by directly implementing <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/dao/SaltSource.html'>SaltSource</a> yourself.<p class='paragraph'></p><h4>dao.reflectionSaltSourceUserProperty</h4><p class='paragraph'></p>For the first approach, you need to set the <code>dao.reflectionSaltSourceUserProperty</code> configuration property, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.dao.reflectionSaltSourceUserProperty = 'username'</pre></div><p class='paragraph'></p>Note that this is a property of the <code>UserDetails</code> class, which by default is an instance of <code>org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</code> which extends the standard Spring Security <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/userdetails/User.html'>User</a>, and not your 'person' domain class. This limits the available fields unless you use a custom <code>UserDetailsService</code> as described <a class='guide' href='../guide/single.html#7. Custom UserDetailsService'>here</a>.<p class='paragraph'></p>As long as the username won't change, it's a good choice for the salt. If you choose a property that the user can change, then they won't be able to log in again after changing it unless you re-encrypt their password with the new value, so it's best to use a property that doesn't change.<p class='paragraph'></p>Another option is to generate a random salt when creating users and store this in the database by adding a new field to the 'person' class. This requires a custom <code>UserDetailsService</code> since you need a custom <code>UserDetails</code> implementation that also has a 'salt' property, but this is more flexible and works in cases where users can change their username.<p class='paragraph'></p><h4>Custom <code>SaltSource</code></h4><p class='paragraph'></p>To have full control over the process, you can implement the <code>SaltSource</code> interface and replace the plugin's implementation with your own by defining a bean in <code>grails-app/conf/spring/resources.groovy</code> with the name <code>saltSource</code>:<p class='paragraph'></p><div class='code'><pre>beans = {
   saltSource(com.foo.bar.MySaltSource) {
      // set properties
   }
}</pre></div><p class='paragraph'></p><h4>Encrypting passwords</h4><p class='paragraph'></p>Regardless of the implementation, you need to be aware of what value to use for a salt when creating or updating users, e.g. in a <code>UserController</code>'s <code>save</code> or <code>update</code> action. Then encrypting the password, you use the two-parameter version of <code>springSecurityService.encodePassword()</code>, e.g.<p class='paragraph'></p><div class='code'><pre>class UserController {<p class='paragraph'></p>   def springSecurityService<p class='paragraph'></p>   def save = {
      def userInstance = <span class='java-keyword'>new</span> User(params)
      userInstance.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      <span class='java-keyword'>if</span> (!userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'create', model: [userInstance: userInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The user was created"</span>
      redirect action: show, id: userInstance.id
   }<p class='paragraph'></p>   def update = {
      def userInstance = User.get(params.id)<p class='paragraph'></p><span class='java-keyword'>if</span> (userInstance.password != params.password) {
         params.password = springSecurityService.encodePassword(
                    params.password, userInstance.username)
      }
      userInstance.properties = params
      <span class='java-keyword'>if</span> (!userInstance.save(flush: <span class='java-keyword'>true</span>)) {
         render view: 'edit', model: [userInstance: userInstance]
         <span class='java-keyword'>return</span>
      }<p class='paragraph'></p><span class='java-keyword'>if</span> (springSecurityService.loggedIn &amp;&amp;
               springSecurityService.principal.username == userInstance.username) {
         springSecurityService.reauthenticate userInstance.username
      }<p class='paragraph'></p>      flash.message = <span class='java-quote'>"The user was updated"</span>
      redirect action: show, id: userInstance.id
   }
}</pre></div><p class='paragraph'></p><h2><a name='10.6. Certificate (X509) login'>10.6. Certificate (X509) login</a></h2>Another authentication mechanism supported by Spring Security is certificate-based, or "mutual authentication". To use this you must use HTTPS and configure the server to require a client certificate (ordinarily only the server provides a certificate). Your username will be extracted from the client certificate if it's valid, and you'll be considered "pre-authenticated". As long as there is a corresponding user in the database with that username, your authentication will succeed and you won't be asked for a password, and the your <code>Authentication</code> will contain the authorities associated with your username.<p class='paragraph'></p>There are a few configuration options available for this feature:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>useX509</td><td><code>false</code></td><td>whether to support certificate-based logins</td></tr><tr class='table-even'><td>x509.continueFilterChainOnUnsuccessfulAuthentication</td><td><code>true</code></td><td>whether to proceed when an authentication attempt fails to allow other authentication mechanisms to process the request</td></tr><tr class='table-odd'><td>x509.subjectDnRegex</td><td>'CN=(.*?),'</td><td>the regex for extracting the username from the certificate's subject name</td></tr><tr class='table-even'><td>x509.checkForPrincipalChanges</td><td><code>false</code></td><td>whether to re-extract the username from the certificate and check that it's still the current user when there's a valid <code>Authentication</code> already</td></tr><tr class='table-odd'><td>x509.invalidateSessionOnPrincipalChange</td><td><code>true</code></td><td>whether to invalidate the session if the principal changed (based on a <code>checkForPrincipalChanges</code> check)</td></tr></table><p class='paragraph'></p>The details around configuring your server for SSL and configuring browser certificates are beyond the scope of this document, but if you're using Tomcat you should look at its <a target='blank' href='http://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html'>SSL documentation</a>. Also, one quick way to get a test environment working is to use the instructions from <a target='blank' href='http://stackoverflow.com/questions/1180397/tomcat-server-client-self-signed-ssl-certificate'>this discussion at Stack Overflow</a>.
<h2><a name='10.7. Channel security'>10.7. Channel security</a></h2>If you are using SSL for some or all of the URLs in your app, you can configure which require HTTP and which require HTTPS using channel security.<p class='paragraph'></p>To configure this, build a Map under the <code>secureChannel.definition</code> key, where the keys are URL patterns, and the values are one of <code>REQUIRES_SECURE_CHANNEL</code>, <code>REQUIRES_INSECURE_CHANNEL</code>, or <code>ANY_CHANNEL</code>:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.secureChannel.definition = [
   '/login/**':         'REQUIRES_SECURE_CHANNEL',
   '/maps/**':          'REQUIRES_INSECURE_CHANNEL',
   '/images/login/**':  'REQUIRES_SECURE_CHANNEL'
   '/images/**':        'ANY_CHANNEL'
]</pre></div><p class='paragraph'></p>URLs will be checked in order, so be sure to put more specific rules before less specific. In the example above <code>/images/login/**</code> is more specific than <code>/images/**</code> so it appears first in the configuration.<p class='paragraph'></p><h2><a name='10.8. IP Address Restrictions'>10.8. IP Address Restrictions</a></h2>Ordinarily it's sufficient to guard URLs with roles, but the plugin provides an extra layer of security with its ability to restrict by IP address. One use for this would be to guard an admin-only part of your site to only be accessible from IP addresses of the local LAN or VPN, e.g. 192.168.1.xxx or 10.xxx.xxx.xxx. This can also be done at your firewall and/or routers, but it can be convenient to have this encapsulated within your application.<p class='paragraph'></p>To use this feature, specify an <code>ipRestrictions</code> configuration map, where the keys are URL patterns, and the values are IP address patterns that can access those URLs. The IP patterns can be single-valued strings, or multi-valued lists of strings and can use <a target='blank' href='http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing'>CIDR</a> masks, and can specify either IPv4 or IPv6 patterns. For example, given this configuration:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.ipRestrictions = [
   '/pattern1/**': '123.234.345.456',
   '/pattern2/**': '10.0.0.0/8',
   '/pattern3/**': ['10.10.200.42', '10.10.200.63']
]</pre></div><p class='paragraph'></p>then <code>pattern1</code> URLs can only be access from the external address 123.234.345.456, <code>pattern2</code> URLs can only be accessed from a 10.xxx.xxx.xxx intranet address, and <code>pattern3</code> URLs can only be accessed from 10.10.200.42 or 10.10.200.63. All other URL patterns are accessible from any IP address.<p class='paragraph'></p>Note that all addresses can always be accessed from localhost regardless of IP pattern, primarily to support local development mode.<p class='paragraph'></p><blockquote class='note'>
You cannot compare IPv4 and IPv6 addresses, so if your server supports both, you need to specify the IP patterns using whichever address format is actually being used, otherwise the filter will throw exceptions. One option is to set the <code>java.net.preferIPv4Stack</code> system property, e.g. by adding it to <code>JAVA_OPTS</code> or <code>GRAILS_OPTS</code> as <code>-Djava.net.preferIPv4Stack=true</code></blockquote><p class='paragraph'></p><h2><a name='10.9. Logout Handlers'>10.9. Logout Handlers</a></h2>Spring Security allows you to register a list of logout handlers (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html'>LogoutHandler</a> interface) that will be called when a user explicitly logs out.<p class='paragraph'></p>By default, a <code>securityContextLogoutHandler</code> bean is registered to clear the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html'>SecurityContextHolder</a>. Also, if you're not using Facebook or OpenID, <code>rememberMeServices</code> bean is registered to reset your cookie (Facebook and OpenID authenticate externally so we don't have access to the password to create a remember-me cookie). If you're using Facebook, a <code>facebookLogoutHandler</code> is registered to reset its session cookies.<p class='paragraph'></p>To customize this list, you define a <code>logout.handlerNames</code> attribute with a list of bean names. The beans must be declared either by the plugin or by you in <code>resources.groovy</code> or <code>resources.xml</code>. So if you have a custom <code>MyLogoutHandler</code> in <code>resources.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myLogoutHandler(com.foo.MyLogoutHandler) {
      // attributes
   }
}</pre></div>
then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.logout.handlerNames = [
   'rememberMeServices', 'securityContextLogoutHandler', 'myLogoutHandler'
]</pre></div><p class='paragraph'></p><h2><a name='10.10. Voters'>10.10. Voters</a></h2>Spring Security allows you to register a list of voters (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/access/AccessDecisionVoter.html'>AccessDecisionVoter</a> interface) that check that a successful authentication is applicable for the current request. By default a <code>roleVoter</code> bean is registered to ensure users have the required roles for the request, and an <code>authenticatedVoter</code> bean is registered to support <code>IS_AUTHENTICATED_FULLY</code>, <code>IS_AUTHENTICATED_REMEMBERED</code>, and <code>IS_AUTHENTICATED_ANONYMOUSLY</code> tokens.<p class='paragraph'></p>To customize this list, you define a <code>voterNames</code> attribute with a list of bean names. The beans must be declared either by the plugin, or yourself in resources.groovy or resources.xml. So if you have a custom MyAccessDecisionVoter in resources.groovy, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myAccessDecisionVoter(com.foo.MyAccessDecisionVoter) {
      // attributes
   }
}</pre></div><p class='paragraph'></p>then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.voterNames = [
   'authenticatedVoter', 'roleVoter', 'myAccessDecisionVoter'
]</pre></div><p class='paragraph'></p><h2><a name='10.11. Authentication Providers'>10.11. Authentication Providers</a></h2>The plugin registers authentication providers (implementing the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AuthenticationProvider.html'>AuthenticationProvider</a> interface) that perform authentication. By default, three are registered: <code>daoAuthenticationProvider</code> to authenticate using the User and Role database tables, <code>rememberMeAuthenticationProvider</code> to login with a remember-me cookie, and <code>anonymousAuthenticationProvider</code> to create an 'anonymous' authentication if no other provider authenticates.<p class='paragraph'></p>To customize this list, you define a <code>providerNames</code> attribute with a list of bean names. The beans must be declared either by the plugin, or yourself in <code>resources.groovy</code> or <code>resources.xml</code>. So if you have a custom <code>MyAuthenticationProvider</code> in <code>resources.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>beans = {
   myAuthenticationProvider(com.foo.MyAuthenticationProvider) {
      // attributes
   }
}</pre></div><p class='paragraph'></p>then you'd register it in <code>grails-app/conf/Config.groovy</code> as:<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.providerNames = ['myAuthenticationProvider',
                                               'anonymousAuthenticationProvider',
                                               'rememberMeAuthenticationProvider']</pre></div><p class='paragraph'></p><h2><a name='10.12. Hierarchical Roles'>10.12. Hierarchical Roles</a></h2>Hierarchical roles are a convenient way to reduce some clutter in your request mappings. For example, if you have several types of 'admin' roles and any one of them can be used to access some URL pattern, then without using hierarchical roles you need to specify all of them:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SomeController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN', 'ROLE_FINANCE_ADMIN', 'ROLE_SUPERADMIN'])
   def someAction = {
      &#x2026;
   }
}</pre></div><p class='paragraph'></p>But if you have a business rule that says that being granted <code>ROLE_FINANCE_ADMIN</code> implies being granted <code>ROLE_ADMIN</code>, and that being granted <code>ROLE_SUPERADMIN</code> implies being granted <code>ROLE_FINANCE_ADMIN</code>, then you can express that hierarchy as<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.roleHierarchy = '''
   ROLE_SUPERADMIN &gt; ROLE_FINANCE_ADMIN
   ROLE_FINANCE_ADMIN &gt; ROLE_ADMIN
'''</pre></div><p class='paragraph'></p>Then you can simplify your mappings by specifying only the roles that are required:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p><span class='java-keyword'>import</span> grails.plugins.springsecurity.Secured<p class='paragraph'></p>class SomeController {<p class='paragraph'></p>   @Secured(['ROLE_ADMIN'])
   def someAction = {
      &#x2026;
   }
}</pre></div><p class='paragraph'></p>You can also reduce the number of granted roles in the database using this approach - where previously you had to grant <code>ROLE_SUPERADMIN</code>, <code>ROLE_FINANCE_ADMIN</code>, and <code>ROLE_ADMIN</code>, now you only need to grant <code>ROLE_SUPERADMIN</code>.<p class='paragraph'></p><h2><a name='10.13. Account Locking and Forcing Password Change'>10.13. Account Locking and Forcing Password Change</a></h2>Spring Security supports four ways of disabling a user account. When you attempt to log in, the <code>UserDetailsService</code> implementation creates an instance of <code>UserDetails</code> which has these accessors:
<ul class='star'><li><code>isAccountNonExpired()</code></li><li><code>isAccountNonLocked()</code></li><li><code>isCredentialsNonExpired()</code></li><li><code>isEnabled()</code></li></ul><p class='paragraph'></p>and if you use the <a class='Scripts' href='../ref/Scripts/s2-quickstart.html'>s2-quickstart</a> script to create a user domain class, it creates a class with corresponding properties to manage this state.<p class='paragraph'></p>When one of these accessors returns <code>false</code> (i.e. <code>accountExpired</code>, <code>accountLocked</code>, or <code>passwordExpired</code> is <code>true</code> or <code>enabled</code> is <code>false</code>)  a corresponding exception is thrown:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Accessor</strong></th><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Exception</strong></th></tr><tr class='table-odd'><td><code>isAccountNonExpired()</code></td><td><code>accountExpired</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/AccountExpiredException.html'>AccountExpiredException</a></td></tr><tr class='table-even'><td><code>isAccountNonLocked()</code></td><td><code>accountLocked</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/LockedException.html'>LockedException</a></td></tr><tr class='table-odd'><td><code>isCredentialsNonExpired()</code></td><td><code>passwordExpired</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/CredentialsExpiredException.html'>CredentialsExpiredException</a></td></tr><tr class='table-even'><td><code>isEnabled()</code></td><td><code>enabled</code></td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/DisabledException.html'>DisabledException</a></td></tr></table><p class='paragraph'></p>You can configure an exception mapping in <code>Config.groovy</code> to associate a URL to any or all of these exceptions to determine where to redirect after a failure, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.failureHandler.exceptionMappings = [
   'org.springframework.security.authentication.LockedException':             '/user/accountLocked',
   'org.springframework.security.authentication.DisabledException':           '/user/accountDisabled',
   'org.springframework.security.authentication.AccountExpiredException':     '/user/accountExpired',
   'org.springframework.security.authentication.CredentialsExpiredException': '/user/passwordExpired'
]</pre></div><p class='paragraph'></p>Without a mapping for a particular exception, the user will be redirected to the standard login fail page (by default <code>/login/authfail</code>) like they would if they had entered a bad password, but they'll see an error message from this table:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default</strong></th></tr><tr class='table-odd'><td>errors.login.disabled</td><td>"Sorry, your account is disabled."</td></tr><tr class='table-even'><td>errors.login.expired</td><td>"Sorry, your account has expired."</td></tr><tr class='table-odd'><td>errors.login.passwordExpired</td><td>"Sorry, your password has expired."</td></tr><tr class='table-even'><td>errors.login.locked</td><td>"Sorry, your account is locked."</td></tr><tr class='table-odd'><td>errors.login.fail</td><td>"Sorry, we were not able to find a user with that username and password."</td></tr></table><p class='paragraph'></p>Any of these can be customized by setting the corresponding property in <code>Config.groovy</code>, e.g.<p class='paragraph'></p><div class='code'><pre>grails.plugins.springsecurity.errors.login.locked = <span class='java-quote'>"None shall pass."</span></pre></div><p class='paragraph'></p>You can use this functionality to manually lock a user's account or expire the password, but another option would be to automate the process. For example you could use the <a target='blank' href='http://grails.org/plugin/quartz'>Quartz plugin</a> to periodically expire everyone's password and force them to go to a page where they update it. You could also keep track of the date when the users change their passwords and use a Quartz job to expire their passwords once the password is older than some fixed max age.<p class='paragraph'></p><h4>User cache</h4><p class='paragraph'></p>If configured, Spring Security will cache <code>UserDetails</code> instances to save trips to the database. This is managed by the <code>cacheUsers</code> configuration property, and it defaults to <code>false</code> in the plugin but you can enable it if you wish. In general this is a minor optimization since there will most likely be only two small queries during login; one to load the user, and one to load the authorities.<p class='paragraph'></p>If you enable this feature, you must remove any cached instances after making a change that affects login. If you don't, even though a user's account is locked or disabled, logins will still succeed since the database will be bypassed. By removing the cached data, you force them to go to the database and retrieve the latest updates.<p class='paragraph'></p>Here is a sample Quartz job that demonstrates how you might find and disable users with passwords that are too old:<p class='paragraph'></p><div class='code'><pre><span class='java-keyword'>package</span> com.mycompany.myapp<p class='paragraph'></p>class ExpirePasswordsJob  {<p class='paragraph'></p><span class='java-keyword'>static</span> triggers = {
      cron name: 'myTrigger', cronExpression: '0 0 0 * * ?' // midnight daily
   }<p class='paragraph'></p>   def userCache<p class='paragraph'></p>   void execute() {<p class='paragraph'></p>      def users = User.executeQuery(
            'from User u where u.passwordChangeDate &lt;= :cutoffDate',
            [cutoffDate: <span class='java-keyword'>new</span> Date() - 180])<p class='paragraph'></p><span class='java-keyword'>for</span> (user in users) {
         // flush each separately so one failure doesn't rollback all of the others
         <span class='java-keyword'>try</span> {
            user.passwordExpired = <span class='java-keyword'>true</span>
            user.save(flush: <span class='java-keyword'>true</span>)
            userCache.removeUserFromCache user.username
         }
         <span class='java-keyword'>catch</span> (e) {
            log.error <span class='java-quote'>"problem expiring password <span class='java-keyword'>for</span> user $user.username : $e.message"</span>, e
         }
      }
   }
}</pre></div><p class='paragraph'></p><h2><a name='10.13. Remember-me'>10.13. Remember-me</a></h2>Spring Security supports creating a remember-me cookie so users aren't required to login with a username and password for each session. This is optional and is usually implemented as a checkbox on the login form; the default <code>auth.gsp</code> supplied by the plugin has this feature.<p class='paragraph'></p>There are a few configuration attributes related to remember-me:<p class='paragraph'></p><table cellpadding='0' class='wiki-table' border='0' cellspacing='0'><tr><th><strong class='bold'>Property</strong></th><th><strong class='bold'>Default Value</strong></th><th><strong class='bold'>Meaning</strong></th></tr><tr class='table-odd'><td>rememberMe.cookieName</td><td>'grails_remember_me'</td><td>remember-me cookie name - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.alwaysRemember</td><td><code>false</code></td><td>create a remember-me cookie even if there's no checkbox on the form if <code>true</code></td></tr><tr class='table-odd'><td>rememberMe.tokenValiditySeconds</td><td>1209600 (14 days)</td><td>max age of the cookie in seconds</td></tr><tr class='table-even'><td>rememberMe.parameter</td><td>'_spring_security_remember_me'</td><td>Login form remember-me checkbox name</td></tr><tr class='table-odd'><td>rememberMe.key</td><td>'grailsRocks'</td><td>a value used to encode cookies - should be unique per application</td></tr><tr class='table-even'><td>rememberMe.persistent</td><td><code>false</code></td><td>if <code>true</code> store persistent login information in the database</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.domainClassName</td><td>'PersistentLogin'</td><td>domain class used to manage persistent logins</td></tr><tr class='table-even'><td>rememberMe.persistentToken.seriesLength</td><td>16</td><td>the number of characters in the cookie's <code>series</code> attribute</td></tr><tr class='table-odd'><td>rememberMe.persistentToken.tokenLength</td><td>16</td><td>the number of characters in the cookie's <code>token</code> attribute</td></tr><tr class='table-even'><td>atr.rememberMeClass</td><td><a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/authentication/RememberMeAuthenticationToken.html'>RememberMeAuthenticationToken</a></td><td>remember-me authentication class</td></tr></table><p class='paragraph'></p>Three attributes that you're most likely to change are
<ul class='star'><li><code>rememberMe.cookieName</code> - this is purely aesthetic since most users won't look at their cookies, but you probably want the name displayed to be something application-specific and not "grails_remember_me"</li><li><code>rememberMe.key</code> - this is used as part of a salt when encrypting the cookie, so changing it from the default will make it that much harder to do brute force attacks</li><li><code>rememberMe.tokenValiditySeconds</code> - the default is two weeks, but you can set it to whatever makes sense for your application</li></ul><p class='paragraph'></p><h4>Persistent logins</h4><p class='paragraph'></p>The remember-me cookie is very secure but for an even stronger solution you can use persistent logins that store the username in the database. See the <a target='blank' href='http://static.springsource.org/spring-security/site/docs/3.0.x/reference/remember-me.html'>Spring Security docs</a> for a description of the implementation.<p class='paragraph'></p>This is also useful for authentication schemes like OpenID and Facebook, where you don't manage passwords in your database, but most of the other user information is stored locally. Without a password you can't use the standard cookie format, so persistent logins enable remember-me cookies in these scenarios.<p class='paragraph'></p>To use this feature, run the <a class='Scripts' href='../ref/Scripts/s2-create-persistent-token.html'>s2-create-persistent-token</a> script. This will create the domain class, and register its name in <code>grails-app/conf/Config.groovy</code>. It will also enable persistent logins by setting <code>rememberMe.persistent</code> to <code>true</code>.

    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body></html>