Spring Security's expression support (which uses [Spring Expression Language|http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/expressions.html]) allows you to declare the rules for guarding URLs more descriptively than using the traditional approach, and also allows much more fine-grained rules. Where you traditionally would specify a list of role names and/or special tokens (e.g. @IS_AUTHENTICATED_FULLY@), with SpEL you can instead use the embedded scripting language to define simple or complex access rules.

You can read about Spring Security's expression support [here|http://static.springsource.org/spring-security/site/docs/3.0.x/reference/el-access.html].

You can use expressions using any of the three approaches. For example, consider this annotated controller:

{code}
package com.yourcompany.yourapp

import grails.plugins.springsecurity.Secured

class SecureController {

   @Secured(["hasRole('ROLE_ADMIN')"])
   def someAction = {
      ...
   }

   @Secured(["authentication.name == 'ralph'"])
   def someOtherAction = {
      ...
   }
}
{code}

Here we're saying that @someAction@ requires @ROLE_ADMIN@, and @someOtherAction@ requires that the user be logged in with username 'ralph'.

The corresponding @Requestmap@s would be

{code}
new Requestmap(url: "/secure/someAction",
               configAttribute: "hasRole('ROLE_ADMIN'").save()

new Requestmap(url: "/secure/someOtherAction",
               configAttribute: "authentication.name == 'ralph'").save()
{code}

and the corresponding static mappings would be

{code}
grails.plugins.springsecurity.interceptUrlMap = [
   '/secure/someAction':      ["hasRole('ROLE_ADMIN'"],
   '/secure/someOtherAction': ["authentication.name == 'ralph'"]
]
{code}

The Spring Security docs have a [table listing the standard expressions|http://static.springsource.org/spring-security/site/docs/3.0.x/reference/el-access.html#el-common-built-in] which is copied here for reference:

{table}
*Expression* | *Description*
@hasRole([role])@ | Returns true if the current principal has the specified role.
@hasAnyRole([role1,role2])@ | Returns true if the current principal has any of the supplied roles (given as a comma-separated list of strings)
@principal@ | Allows direct access to the principal object representing the current user
@authentication@ | Allows direct access to the current Authentication object obtained from the SecurityContext
@permitAll@ | Always evaluates to true
@denyAll@ | Always evaluates to false
@isAnonymous()@ | Returns true if the current principal is an anonymous user
@isRememberMe()@ | Returns true if the current principal is a remember-me user
@isAuthenticated()@ | Returns true if the user is not anonymous
@isFullyAuthenticated()@ | Returns true if the user is not an anonymous or a remember-me user
{table}

In addition, there is a web-specific expression @hasIpAddress@ which you can use. You may find however that it's more convenient to separate IP restrictions from role restrictions using the [IP address filter|guide:10.8. IP Address Restrictions].

To help migrate traditional configurations to expressions, here's a table comparing various configurations and their corresponding expressions:

{table}
*Traditional* | *Expression*
@ROLE_ADMIN@ | @hasRole('ROLE_USER')@
@ROLE_USER,ROLE_ADMIN@ | @hasAnyRole('ROLE_USER,ROLE_ADMIN')@
@ROLE_ADMIN,IS_AUTHENTICATED_FULLY@ | @hasRole('ROLE_ADMIN') and isFullyAuthenticated()@
@IS_AUTHENTICATED_ANONYMOUSLY@ | @permitAll@
@IS_AUTHENTICATED_REMEMBERED@ | @isAnonymous() or isRememberMe()@
@IS_AUTHENTICATED_FULLY@ | @isFullyAuthenticated()@
{table}

